<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Information Retrieval</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/findologic.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
        .node circle {
            fill: none;
            stroke: #ff8c0099;
            stroke-width: 3px;
        }

        .node text {
            font: 1em sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            <script type="text/template">
                # Information Retrieval

                Georg M. Sorst, Principal Engineer @ Nosto
            </script>
        </section>

        <section id="admin"
                 data-markdown="sections/admin.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="getting_to_know_you"
                 data-markdown="sections/getting_to_know_you.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="motivation"
                 data-markdown="sections/motivation.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="boolean_retrieval"
                 data-markdown="sections/boolean_retrieval.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="term_document_matrix"
                 data-markdown="sections/term_document_matrix.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="inverted_index"
                 data-markdown="sections/inverted_index.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="homework_inverted_index"
                 data-markdown="sections/homework_inverted_index.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="tokenization"
                 data-markdown="sections/tokenization.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="stop_words"
                 data-markdown="sections/stop_words.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="stemming"
                 data-markdown="sections/stemming.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="tokenization_example"
                 data-markdown="sections/tokenization_example.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="precision_recall"
                 data-markdown="sections/precision_recall.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="ranked_retrieval"
                 data-markdown="sections/ranked_retrieval.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="homework_tf_idf"
                 data-markdown="sections/homework_tf_idf.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="tf_idf_issues"
                 data-markdown="sections/tf_idf_issues.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="field_weights"
                 data-markdown="sections/field_weights.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="phrase_queries"
                 data-markdown="sections/phrase_queries.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="vocabulary_structure"
                 data-markdown="sections/vocabulary_structure.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="wildcard_queries"
                 data-markdown="sections/wildcard_queries.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="fuzzy_search"
                 data-markdown="sections/fuzzy_search.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>


        <section id="spelling_correction"
                 data-markdown="sections/spelling_correction.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="phonetic_correction"
                 data-markdown="sections/phonetic_correction.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="vector_space_model"
                 data-markdown="sections/vector_space_model.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="scaling"
                 data-markdown="sections/scaling.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="web_search_usage"
                 data-markdown="sections/web_search_usage.md"
                 data-separator="^\n\n\n"
                 data-separator-vertical="^---$">
        </section>

        <section id="web_search_challenges_section">
            <section id="web_search_challenges" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web search challenges

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Technical challenges

                    * Huge amount of data <!-- .element: class="fragment" data-fragment-index="" -->
                    * Frequent updates <!-- .element: class="fragment" data-fragment-index="" -->
                    * Unstructured content <!-- .element: class="fragment" data-fragment-index="" -->
                    * Un-indexable content (images, flash) <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Page quality

                    * <!-- .element: class="fragment" -->**E**xpertise
                    * <!-- .element: class="fragment" -->**A**uthoritativeness
                    * <!-- .element: class="fragment" -->**T**rustworthiness

                    Notes:
                    * Come up with examples of websites that rank high on one of those scales.
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Page quality

                    * Spam <!-- .element: class="fragment" data-fragment-index="1" -->
                    * Duplicate content <!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    * Come up with examples. How could you detect this?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Result quality

                    * User intent <!-- .element: class="fragment" data-fragment-index="" -->
                    * Misspellings <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                    * How could you detect user intent?
                </script>
            </section>
        </section>

        <section id="internet_structure_section">
            <section id="internet_structure" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet Structure
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![web graph](images/web graph.png)

                    * Directed graph connected by hyperlinks
                    * Not strongly connected

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## In-links / Out-links

                    Incoming / Outgoing links

                    ## In-degree / Out-degree

                    Number of incoming / outgoing links

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![web graph](images/web graph.png)

                    * B
                    * In-degree: *3* <!-- .element: class="fragment" data-fragment-index="" -->
                    * Out-degree: *1* <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    Number of web pages with in-degree *i* =

                    $$\frac{1}{i^{2.1}}$$

                    Notes:
                </script>
            </section>

            <section>
                <div class="plot stretch" id="myplot2">
                    <!--
                     {
                      "width": "800",
                      "height": "600",
                      "xAxis": {
                       "domain": ["0", "20"],
                       "label": "In-degree"
                      },
                      "yAxis": {
                       "domain": ["0", "10000"],
                       "label": "Proportional number of pages"
                      },
                      "data": [{ "fn": "10000*1/nthRoot(x, 2.1)" }]
                    }
                    -->
                </div>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![bowtie](images/bowtie.png)<!-- .element: class="stretch" -->

                    Notes:
                </script>
            </section>
        </section>

        <section id="web_crawling_section">
            <section id="web_crawling" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawling

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawler requirements

                    ### Robustness <!-- .element: class="fragment" data-fragment-index="1" -->

                    Handle malicious and faulty pages <!-- .element: class="fragment" data-fragment-index="1" -->

                    ### Politeness <!-- .element: class="fragment" data-fragment-index="2" -->

                    Rate limit <!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawler requirements

                    ### Distributed <!-- .element: class="fragment" data-fragment-index="1" -->

                    Scalable, efficient <!-- .element: class="fragment" data-fragment-index="1" -->

                    ### Quality <!-- .element: class="fragment" data-fragment-index="2" -->

                    Crawl "good" pages more frequently <!-- .element: class="fragment" data-fragment-index="2" -->

                    ### Freshness <!-- .element: class="fragment" data-fragment-index="3" -->

                    Keep index up-to-date <!-- .element: class="fragment" data-fragment-index="3" -->

                    ### Extensible <!-- .element: class="fragment" data-fragment-index="4" -->

                    Data formats, protocols <!-- .element: class="fragment" data-fragment-index="4" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Crawling

                    ![Web crawler architecture](images/WebCrawlerArchitecture.svg)<!-- .element: style="padding: 25px;" class="stretch" -->

                    [Source](https://de.wikipedia.org/wiki/Datei:WebCrawlerArchitecture.svg)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # URL Queue

                    * aka. *Crawl frontier*
                    * Priority queue

                    `priority = f(quality, importance, change rate)`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed Crawling

                    * Partition by domain
                    * Cache DNS
                    * Locality

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link graph

                    ![web graph](images/web graph.png)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link graph

                    * Connectivity servers / indices
                    * Store web graph, in- and out-links
                    * Support graph queries: in- / out-links, in- / out-degree, traversal
                    * Used for link analysis etc.

                    Notes:
                </script>
            </section>
        </section>

        <section id="google_section">
            <section id="google" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What would Google do?

                    [Web search for a planet: the google cluster architecture (2003)](https://static.googleusercontent.com/media/research.google.com/de//archive/googlecluster-ieee.pdf)

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic assumptions

                    * Search can be parallelized
                    * High-end hardware fails too
                    * Throughput > performance
                    * Queries per second > Seconds per query

                    &darr;

                    * Rely on software, not hardware
                    * Use commodity hardware
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Parallelize

                    * Focus on parallel queries
                    * Achieve high throughput
                    * Parallelize at CPU or Cluster level
                    * 10s query parallelized on 10 nodes takes 1s

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query time

                    ![Google cluster](images/google-cluster.png)[Source](https://static.googleusercontent.com/media/research.google.com/de//archive/googlecluster-ieee.pdf) <!-- .element: style="font-size: smaller;" -->

                    * Index servers: Inverted Index, document-partitioned
                    * Document servers: Copy of entire internet
                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query time

                    1. Query index servers &rarr; doc IDs
                    2. Merge doc IDs &rarr; result set
                    3. Fetch doc IDs from doc servers &rarr; (Title, URL, result snippet)
                    4. Generate search result page

                    Notes:
                </script>
            </section>
        </section>

        <section id="web_spam_section">
            <section id="web_spam" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web spam

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Types of web spam

                    * Keyword spam (exploits TF metric)<!-- .element: class="fragment" data-fragment-index="" -->
                    * Cloaking (show different page for human / crawler)<!-- .element: class="fragment" data-fragment-index="" -->
                    * Meta tags<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Counter web spam

                    * Link analysis

                    Notes:
                </script>
            </section>
        </section>

        <section id="link_analysis_section">
            <section id="link_analysis" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link analysis

                    Notes:
                    How to use link analysis to determine relevant pages?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Assumption

                    ![web graph](images/web graph.png)

                    * In-link = endorsement
                    * Similar to citation analysis

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link info

                    * Anchor text describes target page
                        * "[computer manufacturer](http://lenovo.com)" &rarr; lenovo.com
                    * Also text surrounding links
                        * "Find funny cat pics [here](http://icanhascheezburger.com)"
                    * May also be abused
                        * "[evil empire](http://www.korea-dpr.com/)"

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # PageRank

                    * Rank pages with many in-links higher
                    * PageRank =~ In-degree
                    * But harder to influence as it propagates
                    * One in-link from high PageRank site worth more than many low PageRank in-link
                    * Probability that random surfer will end up on page

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # PageRank vs In-Degree

                ![PageRank vs In-Degree](images/PageRank vs In-Degree.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle; width: 40%;" -->

                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Pagerank calculation

                    1. Assume random surfer
                    2. Randomly walk web graph
                        * No out-links &rarr; teleport
                        * 15% chance that user opens random page
                    3. Count how many times page is visited

                    $$\sum \text{pagerank} = 1$$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    [Pagerank visualization](http://bl.ocks.org/emeeks/raw/f448eef177b5fe94b1c0/)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Reasonable surfer

                    * Clicks some links more often than others<!-- .element: class="fragment" -->
                    * Main content vs sidebar / footer<!-- .element: class="fragment" -->
                    * Anchor text related to query / user intent<!-- .element: class="fragment" -->
                    * Avoid ads<!-- .element: class="fragment" -->

                    Notes:
                    How can the random surfer be improved to provide more realistic results?
                </script>
            </section>
        </section>

        <section id="machine_learning_overview_section">
            <section id="machine_learning_overview" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Machine Learning
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Supervised Learning

                ###### Here are cats:

                ![cat1](images/cat1.webp)<!-- .element: height="100px" -->
                ![cat2](images/cat2.webp)<!-- .element: height="100px" -->
                ![cat3](images/cat3.webp)<!-- .element: height="100px" -->

                ###### Here are dogs:

                ![dog1](images/dog1.webp)<!-- .element: height="100px" -->
                ![dog2](images/dog2.webp)<!-- .element: height="100px" -->
                ![dog3](images/dog3.webp)<!-- .element: height="100px" -->

                ## Computer: Is this a cat or a dog?

                ![catdog](images/catdog.jpeg)<!-- .element: height="150px" -->

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Unsupervised learning

                ###### Here are pictures of animals:

                ![cat1](images/cat1.webp)<!-- .element: height="100px" -->
                ![cat3](images/cat3.webp)<!-- .element: height="100px" -->
                ![dog1](images/dog1.webp)<!-- .element: height="100px" -->
                ![dog2](images/dog2.webp)<!-- .element: height="100px" -->
                ![cat2](images/cat2.webp)<!-- .element: height="100px" -->
                ![dog3](images/dog3.webp)<!-- .element: height="100px" -->

                ## Computer: Group similar ones

                ###### Pointy ears:

                ![cat1](images/cat1.webp)<!-- .element: height="100px" -->
                ![cat2](images/cat2.webp)<!-- .element: height="100px" -->
                ![cat3](images/cat3.webp)<!-- .element: height="100px" -->

                ###### Floppy ears:

                ![dog1](images/dog1.webp)<!-- .element: height="100px" -->
                ![dog2](images/dog2.webp)<!-- .element: height="100px" -->
                ![dog3](images/dog3.webp)<!-- .element: height="100px" -->

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Reinforcement Learning

                ![Super Mario](images/super mario.webp)<!-- .element: height="500px" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Transfer Learning

                ###### I like this style

                ![Starry Night](images/starry night.jpeg)<!-- .element: height="200px" -->

                ###### Computer: Apply this style to a picture of a cat

                ![Starry Cat](images/starry cat.jpeg)<!-- .element: height="200px" -->

                <!-- .element: style="font-size: small; color: grey" -->Source: https://discuss.pixls.us/t/style-transfer-soon-in-gmic/10009
                </script>
            </section>
        </section>

        <section id="classification_section">
            <section id="classification" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Text Classification

                    ## Supervised Learning

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What?

                    * Assign document to class(es)
                    * Based on document features:
                        * Contents
                        * Age
                        * Popularity
                        * …

                    Notes:

                    * What are use cases?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Standing queries (Google Alerts)
                    * Spam filter
                    * Webspam detection
                    * Language detection
                    * Sentiment detection

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    * Make humans do it<!-- .element: class="fragment" data-fragment-index="1" -->
                        * Needs domain experts<!-- .element: class="fragment" data-fragment-index="1" -->
                        * Does not scale with amount of data<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Make machines do it<!-- .element: class="fragment" data-fragment-index="2" -->
                        * Needs lots of data<!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    * How?
                    * What's the issue with humans doing it?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Supervised learning

                    <p class="stretch">![Supervised Learning](images/Supervised Learning.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Supervised Learning Example

                    ![Man Woman Classifier](images/Man Woman Classifier.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## Learning Method

                    Computes classifier

                    ## Classifier

                    Determines class of document

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Class membership

                    | Type | Example |
                    |-|-|
                    | Single / one-of | Spam<!-- .element: class="fragment" --> |
                    | Multiple / any-of | Blog categories<!-- .element: class="fragment" --> |

                    # Classifiers

                    | Type | Example |
                    |-|-|
                    | One class | Spam <!-- .element: class="fragment" --> |
                    | Two class | Sentiment <!-- .element: class="fragment" --> |
                    | Multi class | Blog categories  <!-- .element: class="fragment" --> |

                    Notes:
                    Examples?
                </script>
            </section>
        </section>

        <section id="fitting_section">
            <section id="fitting" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Overfitting

                ![Overfitting](images/Man Woman Classifier Overfitting.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Underfitting

                ![Underfitting](images/Man Woman Classifier Underfitting.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Bias-Variance trade-off

                How does classifier change per training set?

                |  | High Variance | High Bias |
                |---|---|---|
                | Accurate | x | - |
                | Overfitting, memorize noise | x | - |
                | Consistent | - | x |
                | Underfitting, cannot learn signal | - | x |

                </script>
            </section>
        </section>

        <section id="feature_selection_section">
            <section id="feature_selection" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Feature Selection

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Why?

                * Do not use all terms for training
                * Less terms = better training and runtime performance
                * Reduce noise

                Notes:
                Ideas?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Text analysis

                * Stopwords (_and_, _or_ do not say anything about spamminess)
                * Stemming (_viagra_, _viagras_ are equally spammy)
                * N-Grams, word sequences

                Notes:
                </script>
            </section>
        </section>

        <section id="naive_bayes_section">
            <section data-markdown>
                <textarea data-template>
                    # Naive Bayes Classification
                </textarea>
            </section>
            <section id="naive_bayes" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability

                    Probability of A if B:

                    $$P(A | B)$$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability Examples

                    Probability of snow if winter:<!-- .element: class="fragment" -->

                    $$P(\text{snow in winter} | \text{winter}) = \frac{\text{Days with snow in winter}}{\text{Days in winter}} = \frac{15}{90} =
                    16\%$$<!-- .element: class="fragment" -->

                    Probability of snow if summer:<!-- .element: class="fragment" -->

                    $$P(\text{snow in summer} | \text{summer}) = \frac{\text{Days with snow in summer}}{\text{Days in summer}} = \frac{0}{90} =
                    0\%$$<!-- .element: class="fragment" -->

                    Probability of winter if it snows:<!-- .element: class="fragment" -->

                    $$P(\text{snow in winter} | \text{snow all year}) = \frac{\text{Days with snow in winter}}{\text{Days with snow all year}} =
                    \frac{15}{17} =
                    88\%$$<!-- .element: class="fragment" -->

                    Notes:
                    Audience questions
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability Examples

                    Probability that it will snow:<!-- .element: class="fragment" -->

                    $$P(\text{snow}) = \frac{\text{Days with snow per year}}{\text{Days in the year}} = \frac{17}{365} =
                    5\%$$<!-- .element: class="fragment" -->

                    Probability of winter:<!-- .element: class="fragment" -->

                    $$P(\text{winter}) = \frac{\text{Days in winter per year}}{\text{Days in the year}} = \frac{90}{365} =
                    25\%$$<!-- .element: class="fragment" -->

                    Notes:
                    Audience questions
                </script>
            </section>

            <section>
                <h1>Bayes Theorem</h1>

                \[\begin{aligned}
                P(A | B) &= \frac{P(A) \times P(B | A)}{P(B)}\\
                \\
                P(\text{winter} | \text{snow}) &= \frac{P(\text{winter}) \times P(\text{snow} | \text{winter})}{P(\text{snow})}\\
                \\
                &= \frac{0.25 \times 0.16}{0.05} = 0.8\\
                \\
                &\approx \frac{\text{Days with snow in winter}}{\text{Days with snow all year}} = \frac{15}{17} = 0.88
                \end{aligned}\]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Bayes for text classification

                    Probability that documents belongs to $class$ if document contains $term$:<!-- .element: class="fragment" data-fragment-index="1" -->

                    $$P(class | term)$$<!-- .element: class="fragment" data-fragment-index="1" -->

                    Probability of spam if mail contains $\text{viagra}$:<!-- .element: class="fragment" data-fragment-index="2" -->

                    $$P(\text{spam} | \text{viagra})$$<!-- .element: class="fragment" data-fragment-index="2" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Example

                https://docs.google.com/spreadsheets/d/1Cim4llHxSKF-meYq8qZEZmVU8OUPMDiBvFj4WCNPv34/edit?usp=sharing

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/markdown">
                    # Probability of Spam if document

                    *I have this document, is it Spam?*

                    (Using extended form of Bayes theorem because spam / ham is a binary variable)

                    <div>
                    \begin{aligned}
                    \\\\
                    P(\text{spam} | doc) &= \frac{P(\text{spam}) \times P(doc | \text{spam})}{P(\text{spam}) \times P(doc | \text{spam}) + P(\text{ham}) \times P(doc | \text{ham})}\\\\
                    \\\\
                    \end{aligned}
                    </div>

                    Spam is one-of class membership so

                    $$P(\text{spam} | doc) + P(\text{ham} | doc) = 100\%$$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Probability of Spam

                *What percentage of all mails is Spam?*

                $$P(\text{spam}) = \frac{\text{Number of spam mails}}{\text{Total number of mails}}$$<!-- .element: class="fragment" -->

                <br />

                $$P(\text{spam}) + P(\text{ham}) = 100\%$$<!-- .element: class="fragment" -->

                Notes:
                Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/markdown">
                    # Probability of document if Spam

                    *Looking at Spam, what are the chances to see this document?*

                    <div>
                    \begin{aligned}
                    \\\\
                    P(doc | \text{spam}) &= \prod_{\text{term} \in \text{doc}} P(term | \text{spam}) = P(t_1 | \text{spam}) \times P(t_2 | \text{spam}) \times …
                    \end{aligned}
                    </div>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Probability of term if Spam

                *Looking at Spam, what are the chances to see this term?*

                <div>
                    \begin{aligned}
                    \\\\
                    P(term | \text{spam}) &= \frac{\text{Document frequency of }term\text{ in Spam}}{\text{Number of Spam mails}}
                    \end{aligned}
                </div>
                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Probability for unknown words

                $P(\text{unknown spam word} | \text{spam}) = \frac{0}{\text{Number of Spam mails}} = 0$

                so

                $P(doc | \text{spam}) = P(\text{viagra} | \text{spam}) \times P(\text{unknown spam word} | \text{spam}) \times \text{…} = 0$

                But the probability should be $> 0%$.

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Laplace Smoothing

                <div>
                    \begin{aligned}
                    P(term | \text{spam}) &= \text{Probability of mail containing }term\text{ if it is Spam}\\\\
                    &= \frac{\text{Document frequency of }term\text{ in Spam} + 1}{\text{Number of Spam mails} + 2}
                    \end{aligned}
                </div>

                <br />

                Constants are added so $0\% < \text{probability} < 100\%$.

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Probability of term

                *What is the percentage of mails containing this term?*

                $$P(term) = \frac{\text{Document frequency of }term + 1}{\text{Total number of mails} + 2}$$

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Probability of spam if term

                *I have this term, is it Spam?*

                $$P(\text{spam} | term) = \frac{P(\text{spam}) \times P(term | \text{spam})}{P(\text{spam}) \times P(term | \text{spam}) + P(\text{ham}) \times P(term | \text{ham})}$$

                <br />

                $$P(\text{spam} | term) + P(\text{ham} | term) = 100\%$$

                Notes:
                How to calculate these probabilities?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Spam or Ham?

                    If $P(\text{spam} | content) > P(\text{ham} | content)$ then mail is spam, so:

                    $$\text{Spam}: \frac{P(\text{spam} | content)}{P(\text{ham} | content)} > 1$$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Naive Bayes

                    * Naive = Assumes features are independent
                        * Features: ("rolex", "replica") are not independent
                    * Predicts probability for class, not class
                    * Robust to concept drift ("viagra" &rarr; "cialis")
                    * Robust to noise ("unusual" documents)
                    * Efficient and effective

                    Notes:

                    * Example for dependent features?
                </script>
            </section>
        </section>

        <section id="homework_naive_bayes_section">
            <section id="homework_naive_bayes" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Homework

                ## Implement spam filtering using naive bayes

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ```
                Enter text to classify, empty to quit: later friend
                P(spam | "later friend"): 1.3958381774904292%
                P(ham | "later friend"): 98.60416182250957%
                "later friend" is not spam

                Enter text to classify, empty to quit: free nokia mobile
                P(spam | "free nokia mobile"): 99.990687845424%
                P(ham | "free nokia mobile"): 0.009312154575997407%
                "free nokia mobile" is spam

                Enter text to classify, empty to quit:
                ```
                <!-- .element: class="stretch" -->

                Notes:
                </script>
            </section>
            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Homework

                * Build a Spam Classifier using Naive Bayes
                * [Use the provided setup](https://gitlab.mediacube.at/information-retrieval/homework-naive_bayes), make sure to read [`README.md`](https://gitlab.mediacube.at/information-retrieval/homework-naive_bayes/-/blob/master/README.md)
                * Use `data.txt` for training
                * Implement the required probability calculation formulas
                * Carefully think about what you can pre-calculate during start-up to save time when classifying
                * Your application should be able to handle millions of texts
                * **Focus on correct implementation of the required formulas**
                * Use the provided CLI to manually test your application (see `README.md`)
                * Ensure that the provided test cases run successfully (see `README.md`)

                Notes:
                </script>
            </section>
        </section>

        <section id="vector_space_classification_section">
            <section id="vector_space_classification" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Vector Space Classification
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Document as vector

                <p class="stretch">![Vectors](images/Vectors.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                <p class="stretch">![Vector Space Classification](images/Vector Space Classification.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Rocchio Classification

                Supports multiple classes

                1. Compute center of mass / centroid for class
                2. Assign documents to class of nearest centroid
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Rocchio Classification

                <p class="stretch">![Rocchio](images/Rocchio.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:

                What is the class of the new document?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # k Nearest Neighbor (kNN)

                Supports multiple classes

                * Assign document to class of the majority of the k nearest neighors
                * $k = 1$: Closest neighbor
                * Usually $k = 3$ or $k = 5$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # k Nearest Neighbor (kNN)

                <p class="stretch">![kNN](images/kNN.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:

                What's the class?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Support Vector Machines (SVM)

                Supports exactly two classes

                * Separate documents into two classes
                * By drawing a _line_ between the two classes

                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Which _line_?

                <p class="stretch">![SVM Possibilities](images/SVM Possibilities.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:

                Audience question. Which line and why?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Hyperplane

                * 1 dimensional: point
                * 2 dimensional: line
                * 3 dimensional: plane

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Which hyperplane?

                Choose hyperplane with largest margin:

                Larger margin

                &darr;

                More wiggle room for both classes

                &darr;

                More confident decision

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Hyperplane with largest margin

                <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # SVM Outliers

                <p class="stretch">![SVM Outliers](images/SVM Outliers Problem.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Outliers decrease margin

                <p class="stretch">![SVM Outliers](images/SVM Outliers.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # SVM Outliers

                * Outliers could be noise
                * Ignore for greater margin
                * Pay penalty for each outlier

                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # SVM Outliers

                <p class="stretch">![SVM Outliers](images/SVM Outliers Solved.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Linearly inseparable data

                <p class="stretch">![SVM not separable](images/SVM not separable.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # SVM Kernel Trick

                Transform to higher dimension

                <p class="stretch">![SVM Kernel Trick](images/SVM Kernel Trick.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Which classifier to use?

                * Is the problem linear?
                * Can a hyperplane separate the classes?

                <p class="stretch">![Linear Non-Linear](images/Linear Non-Linear.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Classifier types

                * Linear classifier: Separates classes with hyperplane
                * Non-Linear classifier: Opposite
                * Linear classifier is more robust
                * But cannot solve non-linear problems

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Is classifier linear?

                1. Classify new document
                2. Do this many times
                3. Is border between classes a hyperplane?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Rocchio Classification: Linear?

                <p class="stretch">![Rocchio](images/Rocchio.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Rocchio Classification: Linear

                <p class="stretch">![Rocchio Linear](images/Rocchio Linear.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # kNN: Linear?

                <p class="stretch">![kNN](images/kNN.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # kNN: Non-Linear

                <p class="stretch">![kNN Non-Linear](images/kNN Non-Linear.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # SVM

                <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Linear? *Yes*<!-- .element: class="fragment" data-fragment-index="" -->
                Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                <p class="stretch">![Rocchio Linear](images/Rocchio Linear.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                * Bias: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                * Variance: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                <p class="stretch">![kNN Non-Linear](images/kNN Non-Linear.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                * Bias: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                * Variance: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                * Bias: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                * Variance: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>
        </section>

        <section id="word_embedding_section">
            <section id="word_embedding" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Word Embedding

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Prediction

                <!-- .element: class="stretch" -->![Swiftkey](images/swiftkey.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Similarity

                ![Word Embeddings](images/word embeddings.png)

                $$\text{king} - \text{man} + \text{woman} \approx \text{queen}$$

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Word Embedding

                * Use vectors to represent words
                * Embed in multi-dimensional space
                * Similar vectors &approx; Related words
                * Related words &approx; Occur in similar contexts

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Words as vectors

                * **Corpus**: *The quick brown fox jumps over the lazy dog.*
                * **Vocabulary**: [quick, brown, fox, jump, lazy, dog].
                * **Vector for** *brown* (one-hot encoding):

                <div>

                | Word  | Vector |
                |-------|--------|
                | quick | 0      |
                | brown | 1      |
                | fox   | 0      |
                | jump  | 0      |
                | lazy  | 0      |
                | dog   | 0      |

                </div><!-- .element: class="fragment" -->

                Notes:
                What does the vector for brown look like?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Vectors are unrelated

                <p class="stretch">![brown quick vectors unrelated](images/brown quick vectors unrelated.svg)<!-- .element: style="border: none; box-shadow: none" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Embed word vectors

                <p class="stretch">![brown quick vectors related](images/brown quick vectors related.svg)<!-- .element: style="border: none; box-shadow: none" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Train similarity

                <div>
                    \begin{aligned}
                    sim(\text{quick}, \text{brown}) &> sim(\text{quick}, \text{dog})\\\\
                    sim(\begin{pmatrix}1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\end{pmatrix}, \begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\end{pmatrix}) &> sim(\begin{pmatrix}1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\end{pmatrix}, \begin{pmatrix}0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\end{pmatrix})
                    \end{aligned}
                </div>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Training data

                *The quick brown fox jumps over the lazy dog.*

                Slide window over corpus:

                1. <!-- .element: class="fragment" --> *<span class="highlight-fl">The quick</span> brown fox jumps over the lazy dog*: [*the* &rarr; *quick*]
                2. <!-- .element: class="fragment" --> *The <span class="highlight-fl">quick brown</span> fox jumps over the lazy dog*: [*quick* &rarr; *brown*]
                3. <!-- .element: class="fragment" --> *The quick <span class="highlight-fl">brown fox</span> jumps over the lazy dog*: [*brown* &rarr; *fox*]

                <!-- .element: class="fragment" -->When Machine sees *brown* it should predict *fox*.

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Skipgram

                Predict context from word.

                1. *<span class="highlight-fl">The <u>quick</u> brown</span> brown fox jumps over the lazy dog*: [*quick* &rarr; *the*, *brown*]
                2. *The <span class="highlight-fl">quick <u>brown</u> fox</span> jumps over the lazy dog*: [*brown* &rarr; *quick*, *fox*]
                3.  *The quick <span class="highlight-fl">brown <u>fox</u> jumps</span> over the lazy dog*: [*fox* &rarr; *brown*, *jumps*]

                When Machine sees *quick* it should predict *the* or *brown*.

                Window can be larger (recommended: 5).

                Skipgram well suited for small data sets with rare words.

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Continuous Bag of Words (CBOW)

                Predict word from context.

                1. *<span class="highlight-fl"><u>The</u> quick <u>brown</u></span> brown fox jumps over the lazy dog*: [*the*, *brown* &rarr; *quick*]
                2. *The <span class="highlight-fl"><u>quick</u> brown <u>fox</u></span> jumps over the lazy dog*: [*quick*, *fox* &rarr;  *brown*]
                3.  *The quick <span class="highlight-fl"><u>brown</u> fox <u>jumps</u></span> over the lazy dog*: [*brown*, *jumps* &rarr; *fox*]

                When Machine sees *the* or *brown* it should predict *quick*.

                CBOW trains faster, more accurate for frequent words.

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Word Embedding visualized

                [Word Embedding Visual Inspector](https://ronxin.github.io/wevi/)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Word Embedding play time

                [View Word Embedding Notebook](https://github.com/georgms/information-retrieval/blob/gh-pages/word-embedding/Word%20Embedding.ipynb)

                1. Download [Word Embedding Notebook](word-embedding/Word Embedding.ipynb) and [data.txt](word-embedding/data.txt)
                2. Run Jupyter: `docker run -p 8888:8888 -e GRANT_SUDO=yes -u root jupyterhub/singleuser`
                3. Open http://localhost:8888/lab with the token from the console
                3. Upload Notebook and `data.txt`

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Word2Vec Alternatives

                [fastText](https://fasttext.cc/)

                * Uses n-grams instead of words
                * Can match unknown words by matching n-grams
                * Can also be used for text classification
                * Pre-trained for many languages

                [GloVe](https://nlp.stanford.edu/projects/glove/)

                * Pre-trained for many languages

                Notes:
                </script>
            </section>
        </section>

        <section id="clustering_section">
            <section id="clustering" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Clustering

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What?

                    * Classes are not known
                    * Assign similar documents to same class / cluster

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Show similar documents<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Cluster search results<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Exploratory browsing<!-- .element: class="fragment" data-fragment-index="1" -->
                    * News aggregation<!-- .element: class="fragment" data-fragment-index="1" -->

                    Notes:
                    Why?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    * Unsupervised learning
                    * No labeled documents available

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Types of clustering

                    * *Hard*: Document belongs to exactly one cluster
                    * *Soft*: Document can belong to multiple clusters with varying degrees
                    * *Flat*: One level of clusters
                    * *Hierarchical*: Sub-clusters

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # K-Means

                    1. Set $K$ random centroids
                    2. Assign each document to nearest centroid
                    3. Move centroids to minimize distance to documents
                    4. Terminate or goto 2


                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![K-Means](images/K-Means.png)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    <span style="font-size: x-small">© 2008 Cambridge University Press</span>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Termination

                    * Centroids do not move<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Assignment do not change<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Sum of distances does not decrease<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Sum of distances is below threshold<!-- .element: class="fragment" data-fragment-index="1" -->
                    * After $n$ iterations<!-- .element: class="fragment" data-fragment-index="1" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # K-Means disadvantages

                    * Can get stuck on local minimum
                    * Can build singleton clusters for outliers
                    * Can build empty clusters

                    Notes:
                </script>
            </section>
        </section>

        <section id="machine_learning_section">
            <section id="machine_learning" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Machine Learning for Ranked Retrieval

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Getting field weights right is hard
                    * Title match > Meta keyword match?
                    * Query "iphone": "iPhone cover" > "iPhone X"?

                    <span class="fragment">Just rank by click!</span> <span class="fragment">But what about new items?</span>
                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    1. Calculate weights
                    2. Apply new weights
                    3. Compare actual rank to expected rank (nDCG, MAP, ERR, …)
                    4. Try harder

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # From

                <p class="stretch">![Regular Search pipeline](images/Search pipeline.jpg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # To

                <p class="stretch">![LTR Search pipeline](images/LTR Search pipeline.jpg)
                    <!-- .element: style="border: none; box-shadow: none;" --></p>

                Notes:
                </script>
            </section>
        </section>

        <section id="ltr_section">

            <section id="ltr" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Calculate Weights
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![Machine Learning Training Pipeline](images/Machine Learning Training Pipeline.png)<!-- .element: style="border: none; box-shadow: none;" -->
                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![Regression Learning](images/Regression Learning.png)<!-- .element: style="border: none; box-shadow: none;" -->

                Ideal Rank vs. Actual Rank

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Machine Learning

                * RankSVM
                * PRanking
                * LambdaMART
                * GBRT
                * …

                Notes:
                </script>
            </section>

            <section id="calculate_weights" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Obtain result clicks

                    | Query  | Document<!-- .element: class="fragment" data-fragment-index="1" -->     | Current Rank<!-- .element: class="fragment" data-fragment-index="2" --> | | Clicks<!-- .element: class="fragment" data-fragment-index="3" -->
                    |--------|--------------|-----------|------|
                    | iphone | iPhone cover<!-- .element: class="fragment" data-fragment-index="1" --> | 1<!-- .element: class="fragment" data-fragment-index="2" -->    |         | 2<!-- .element: class="fragment" data-fragment-index="3" -->
                    | iphone | iPhone X<!-- .element: class="fragment" data-fragment-index="1" -->     | 2<!-- .element: class="fragment" data-fragment-index="2" -->    |         | 11<!-- .element: class="fragment" data-fragment-index="3" -->
                    | iphone | iPhone 8<!-- .element: class="fragment" data-fragment-index="1" -->     | 3<!-- .element: class="fragment" data-fragment-index="2" -->    |         | 5<!-- .element: class="fragment" data-fragment-index="3" -->
                    | iphone | iPhone 13<!-- .element: class="fragment" data-fragment-index="1" -->     | 4<!-- .element: class="fragment" data-fragment-index="2" -->    |         | ? (just released)<!-- .element: class="fragment" data-fragment-index="3" -->

                    Or use manual relevance judgement<!-- .element: class="fragment" data-fragment-index="5" -->

                    Ideal ranking:<!-- .element: class="fragment" data-fragment-index="6" -->

                    1. iPhone X<!-- .element: class="fragment" data-fragment-index="6" -->
                    2. iPhone 8<!-- .element: class="fragment" data-fragment-index="6" -->
                    3. iPhone cover<!-- .element: class="fragment" data-fragment-index="6" -->

                    <span class="fragment" data-fragment-index="7">How to rank _iPhone 13_?</span>

                    Notes:

                    What's the optimal ranking?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Features

                    Must be numeric

                    * Keyword / field relevance, using TF-IDF<!-- .element: class="fragment" data-fragment-index="" -->
                        * Query: *iphone*, title: *iPhone X* &rarr; 1
                        * Query: *iphone*, title: *iPhone cover* &rarr; 1
                        * Query: *iphone*, title: *Samsung Galaxy* &rarr; 0
                    * Other attributes<!-- .element: class="fragment" data-fragment-index="" -->
                        * Product age: 5 years
                        * Number of sales: 3.265
                        * Price: 1.300€

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Defining features

                    * Requires human effort and creativity
                    * Machine will figure importance of each feature


                    Notes:
                </script>
            </section>

            <section>
                <h1>Calculate weights</h1>

                <p>$$f(\text{query}, \text{document features}, \text{feature weights}) = \text{ideal rank}$$</p>

                <div class="fragment">
                    <h3>Solve for <em>weights</em>:</h3>

                    \[\begin{aligned}
                    &f(\text{iphone}, \text{iPhone 8}, \text{weights}) &= 2\\
                    &f(\text{iphone}, \text{iPhone X}, \text{weights}) &= 1\\
                    &f(\text{iphone}, \text{iPhone cover}, \text{weights}) &= 3\\
                    \end{aligned}\]
                </div>

                <aside class="notes">

                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Feature Store

                    ```json
                    [{
                        "name":"documentRecency",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!func}recip( ms(NOW,last_updated_dt), 3.16e-11, 1, 1)"},
                        "store":"wikipedia"
                    }, {
                        "name":"popularity",
                        "class":"org.apache.solr.ltr.feature.FieldValueFeature",
                        "params":{"field":"popularity_score_d"},
                        "store":"wikipedia"
                    }, {
                        "name":"totalScore",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!edismax qf=\"title_txt_en headings_txt_en categories_txts_en opening_text_txt_en text_txt_en\"}${text}"},
                        "store":"wikipedia"
                    }, {
                        "name":"titleScore",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!edismax qf=\"title_txt_en\"}${text}"},
                        "store":"wikipedia"
                    }, {
                        "name":"exactTitle",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!df=\"title_exact_s_lower\"}${text}"},
                        "store":"wikipedia"
                    }]
                    ```

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Feature Extraction

                    Query: *iphone x*

                    ```json
                    [{
                        "title_txt_en": "IPhone X",
                        "[features]": "documentRecency:0.94301736 popularity:1.2207552E-5 totalScore:22.804134 titleScore:17.452236 exactTitle:11.403795 headingsScore:0.0 categoriesScore:0.0 openingScore:22.804134 textScore:19.482597"
                    },
                    {
                        "title_txt_en": "OS X Mountain Lion",
                        "[features]": "documentRecency:0.59085584 popularity:3.140487E-6 totalScore:19.74273 titleScore:5.4706 exactTitle:0.0 headingsScore:0.0 categoriesScore:8.784399 openingScore:8.180487 textScore:17.705677"
                    },
                    {
                        "title_txt_en": "IPhone",
                        "[features]": "documentRecency:0.97925586 popularity:6.251065E-5 totalScore:16.994913 titleScore:12.235063 exactTitle:0.0 headingsScore:0.0 categoriesScore:0.0 openingScore:15.402786 textScore:15.681499"
                    }]
                    ```

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    | Rank | Query | Title relevance | Age | More features … | Comment        |
                    |------|----------|-----------------|-----------------|-----------------|----------------|
                    | 2    | *iphone*    | 1.3             | 0.9             | 1             | # iPhone 8     |
                    | 3    | *iphone*    | 1.3             | 0.3             | 0             | # iPhone X     |
                    | 1    | *iphone*    | 1.3             | 1.2             | 0             | # iPhone cover |
                    | ?    | *iphone*    | 1.3             | 0.1             | 0             | # iPhone 13 |
                    | 3    | *galaxy*    | 3.3             | 3.5             | 1             |                |
                    | 2    | *galaxy*    | 1.0             | 1.1             | 1             |                |
                    | 1    | *galaxy*    | 0.5             | 1.2             | 1             |                |

                    Notes:
                </script>
            </section>

            <section>
                <h1>Re-Rank Formula</h1>

                \[\begin{aligned}
                  5   &\times \text{title relevance}\\
                + 3.1 &\times \text{body relevance}\\
                + 4.3 &\times \text{product age}\\
                + 2.2 &\times \text{number of sales}
                \end{aligned} \]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Model Store

                    ```json
                    {
                        "documentRecency":0.053789198,
                        "popularity":2.7602253E-5,
                        "totalScore":0.11210245
                    }
                    ```
                    Notes:
                </script>
            </section>


        </section>

        <section id="ltr_evaluation_section">

            <section id="ltr_evaluation" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Result Evaluation

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # DCG

                    Discounted Cumulative Gain

                    <p class="">![DCG](images/dcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    | $rel_i$ | $2^{rel_i}-1$ | $log_2(i+1)$ | $=$  |
                    |---------|---------------|--------------|------|
                    | 2       | 3             | 1            | 3    |
                    | 3       | 7             | 1.6          | 4.4  |
                    | 1       | 1             | 2            |  0.5 |
                    | $\sum$  |               |              |  7.9 |

                    More results &rarr; higher DCG &rarr; normalize<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # iDCG

                    Ideal Discounted Cumulative Gain

                    <p class="">![iDCG](images/idcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    | $rel_i$ | $2^{rel_i}-1$ | $log_2(i+1)$ | $=$ |
                    |---------|---------------|--------------|-----|
                    | 3       | 7             | 1            | 7   |
                    | 2       | 3             | 1.6          | 1.9 |
                    | 1       | 1             | 2            | 0.5 |
                    | $\sum$  |               |              | 9.4 |

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # nDCG

                    Normalized Discounted Cumulative Gain

                    <p class="">![nDCG](images/ndcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    $7.9 \div 9.4 = 0.8$

                    Perfect ranking: $1.0$<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                    What's the perfect ranking?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Online testing

                    A/B testing

                    Notes:
                </script>
            </section>
        </section>

        <section id="personalization_section">
            <section id="personalization" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Personalization

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Personalization

                    * Different ranking per user
                    * Gender, age
                    * Favorite color, brand

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    Solve

                    $$f(\text{query}, \text{document}, \text{weights}, \text{user context}) = \text{rank}$$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Obtain result clicks

                    | Query | Favorite color | Document   | Clicks | Current Rank |
                    |-------|----------------|------------|-----------|------|
                    | shirt | red            | Blue shirt | 1         | 1    |
                    | shirt | red            | Red shirt  | 5         | 3    |
                    | shirt | blue           | Red shirt  | 2         | 2    |
                    | shirt | blue           | Blue shirt | 8         | 4    |

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    | Rank | Query | Is Favorite Color | FeatureN | Comment |
                    |------|-------|-------------------|-----------------|-------------------------------|
                    | 3 | *red* | 1 | 1 | # Red shirt, user likes red |
                    | 2 | *red* | 0 | 0 | # Red shirt, user likes blue |
                    | 1 | *blue* | 0 | 2 | # Blue shirt, user likes red |
                    | 4 | *blue* | 1 | 0 | # Blue shirt, user likes blue |

                    Notes:
                </script>
            </section>

            <section>
                <h1>Re-Rank Formula</h1>

                \[\begin{aligned}
                5 &\times \text{title relevance}\\
                + 4.3 &\times \text{product age}\\
                + 3.5 &\times \text{user's favorite color}
                \end{aligned} \]
            </section>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Missing topics

                * Hierarchical clustering
                * Relevance feedback
                * Semantic analysis

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Feedback

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # We're hiring

                <p class="stretch>">![Developers](images/developers.gif) <!-- .element: style="width: 60%;" --></p>

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Final projects

                Notes:
            </script>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        anything: [
            {
                className: "chart",
                initialize: (function (container, options) {
                    container.chart = new Chart(container.getContext("2d"), options);
                    Chart.defaults.global.defaultFontColor = "black";
                    Chart.defaults.global.defaultFontSize = 50;
                })
            },
            {
                className: "plot",
                defaults: {grid: true},
                initialize: (function (container, options) {
                    options.target = "#" + container.id;
                    functionPlot(options);
                })
            },
            {
                className: "tree",
                defaults: {
                    width: 1500,
                    height: 500,
                    margin: {
                        top: 50,
                        bottom: 50,
                        left: 50,
                        right: 50
                    },
                    font: "normal 20px Arial"
                },
                initialize: (function (container, options) {
                    let treeData = JSON.parse(container.text);

                    var i = 0;

                    var tree = d3.layout.tree().size([options.height, options.width]);

                    var depthCount = function (branch) {
                        if (!branch.children) {
                            return 1;
                        }
                        return 1 + d3.max(branch.children.map(depthCount));
                    };
                    var maxDepth = depthCount(treeData);
                    var depthIncrement = options.height / (maxDepth - 1);

                    var diagonal = d3.svg.diagonal()
                        .projection(function (d) {
                            return [d.x, d.y];
                        });

                    var svg = d3.select(container.parentElement).insert("svg", function () {
                        return container;
                    })

                        .attr("width", options.width + options.margin.left + options.margin.right)
                        .attr("height", options.height + options.margin.top + options.margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + options.margin.left + "," + options.margin.top + ")");

                    update(treeData);

                    function update(root) {

                        // Compute the new tree layout.
                        var nodes = tree.nodes(root).reverse(),
                            links = tree.links(nodes);

                        nodes.forEach(function (d) {
                            d.x *= 3;
                            d.y = d.depth * depthIncrement;
                        });

                        // Declare the nodes…
                        var node = svg.selectAll("g.node")
                            .data(nodes, function (d) {
                                return d.id || (d.id = ++i);
                            });

                        // Enter the nodes.
                        var nodeEnter = node.enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")";
                            });

                        nodeEnter.append("circle")
                            .attr("r", 10)
                            .style("fill", "#fff");

                        nodeEnter.append("text")
                            .attr("y", function (d) {
                                return d.children || d._children ? -30 : 30;
                            })
                            .attr("dy", ".35em")
                            .attr("text-anchor", "middle")
                            .text(function (d) {
                                return d.name;
                            })
                            .style("fill-opacity", 1)
                            .style("fill", function (d) {
                                return d.fill ? d.fill : undefined;
                            });

                        // Declare the links…
                        var link = svg.selectAll("path.link")
                            .data(links, function (d) {
                                return d.target.id;
                            });

                        // Enter the links.
                        link.enter().insert("path", "g")
                            .attr("class", "link")
                            .attr("d", diagonal);

                    }
                })
            }
        ],
        math: {
            mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
            config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        },
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'node_modules/socket.io.js', async: true},
            {src: 'plugin/notes-server/client.js', async: true},
            {src: 'js/Chart.min.js'},
            {src: 'js/d3.min.js'},
            {src: 'js/function-plot.js'},
            {src: 'plugin/anything/anything.js'},
            {src: 'plugin/math/math.js', async: true},
            {src: 'plugin/reveal.js-menu-1.2.0/menu.js'},
        ]
    });
</script>
</body>
</html>
