<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Text Search 102</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/findologic.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
        .node circle {
            fill: none;
            stroke: #ff8c0099;
            stroke-width: 3px;
        }

        .node text {
            font: 1em sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            <script type="text/template">
                # Text Search 102

                Georg M. Sorst, CTO FINDOLOGIC
            </script>
        </section>

        <section id="admin_section">
            <section id="admin" data-markdown>
                # Administrative
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Me

                    * Georg M. Sorst
                    * CTO for 7 years @ FINDOLOGIC GmbH
                    * One of DACH's biggest search and navigation solution providers
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                ![Über uns](images/ueber-uns.png)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->
                </script>
            </section>

            <section id="career" data-markdown>
                <script type="text/template">
                    # Career @ ![FINDOLOGIC](images/findologic-big.png)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                    * Internship, thesis, full time
                    * Buzzwords:
                        * Angular, Vue, Material Design, Typescript, Laravel, Kotlin
                        * IntelliJ, WebStorm, PHPStorm, YouTrack
                        * GitLab, GitHub, Travis, Jenkins
                        * Kubernetes, Ansible, Docker, Vagrant
                        * Solr
                        * Wuzler
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Org

                    * Close laptops for full attention
                    * Answering questions is relevant for the grade, and helps your fellow students too
                    * Ask questions right away
                    * Final
                    * Final project: Find data set, build search
                    *
                    * Who will be my timekeeper?
                </script>
            </section>
        </section>

        <section id="you" data-markdown data-separator-notes="^Notes:">
            # Getting to know you

            I want to learn your names

            ## Let's play a game – rules:

            1. You know your names
            2. I have a list of all names. It's not in alphabetical order and I cannot reorder it.
            2. You cannot say your name
            3. You can only say *yes* or *no* when asked for a name

            Notes:
            * How long does it take if I just try every name on everyone?
            * What's the fastest to learn all your names?
        </section>

        <section id="motivation_section">
            <section id="motivation" data-markdown>
                <script type="text/template">
                    # Motivation
                </script>
            </section>

            <section data-markdown>
                # Information Retrieval

                > Information retrieval (IR) is the activity of obtaining information system resources relevant to an information need from a collection.

                > Web search engines are the most visible IR applications.
            </section>

            <section>
                <img class="stretch" data-src="images/netcraft.png"/>
            </section>

            <section>
                <img class="stretch" data-src="images/wikipedia.png"/>
            </section>

            <section>
                <img class="stretch" data-src="images/printed-internet.png"/>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Search is everywhere
                    * Internet
                    * eCommerce
                    * CMS, Blogs
                    * Intranet
                    * Academia
                    * ...
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Challenges

                    * High result quality
                    * User friendly
                    * Fast, scalable
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Outlook

                    * BYOG (Build your own Google)
                    * Understand fundamental search data structures and algorithms
                </script>
            </section>
        </section>

        <section id="boolean_retrieval_section">
            <section id="boolean_retrieval" data-markdown>
                <script type="text/template">
                    # Boolean retrieval

                    `AND`, `OR`, `NOT`
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    Find all **documents** containing the **terms** and satisfying the conditions:

                    ```
                    fh AND salzburg
                    ```

                    ```
                    mmt OR mma
                    ```

                    ```
                    mmt AND NOT mma
                    ```

                    ```
                    (information AND retrieval) OR search
                    ```
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Nomenclature

                    ## Documents <!-- .element: class="fragment" data-fragment-index="1" -->
                    Books, chapters, pages, web pages, news posts... <!-- .element: class="fragment" data-fragment-index="1" -->

                    ## Document collection, Corpus <!-- .element: class="fragment" data-fragment-index="2" -->
                    All the documents <!-- .element: class="fragment" data-fragment-index="2" -->

                    ## Terms <!-- .element: class="fragment" data-fragment-index="3" -->
                    Like words, but maybe "FH Salzburg" and "A1" as well <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Will it match?

                    ```
                    (information AND retrieval) OR search
                    ```

                    * <!-- .element: class="fragment" --> \#1: _a book about information retrieval_ <span>&rarr; Match</span><!-- .element: class="fragment" style="color: green;" -->
                    * <!-- .element: class="fragment" --> \#2: _a book about the search for information_ <span>&rarr; Match</span><!-- .element: class="fragment" style="color: green;" -->
                    * <!-- .element: class="fragment" --> \#3: _a book about information_ <span>&rarr; No Match</span><!-- .element: class="fragment" style="color: red;" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## Information need <!-- .element: class="fragment" data-fragment-index="1" -->
                    What the user is looking for <!-- .element: class="fragment" data-fragment-index="1" -->

                    _"learn about information retrieval and search"_ <!-- .element: class="fragment" data-fragment-index="2" -->

                    ## Query <!-- .element: class="fragment" data-fragment-index="3" -->
                    How the user talks to the computer <!-- .element: class="fragment" data-fragment-index="3" -->

                    `(information AND retrieval) OR search` <!-- .element: class="fragment" data-fragment-index="4" -->

                    Notes:
                    If no special syntax for query is required than it is easier to express information need.
                    See semantic search, voice etc.
                </script>
            </section>

            <section data-markdown>
                <script type="text/template">
                    # Simple Boolean Retrieval Implementation

                    1. Calculate result lists for every query term
                      * Grep
                    2. Apply boolean operators
                      * Intersect, Union

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Grep

                    * Query term : *book*
                    * Document string: *a book about information retrieval*

                    Compare query term with document string, from first to last character

                    1. <!-- .element: class="fragment fade-in-then-out" data-fragment-index="1" --><span>a␣bo</span><!-- .element: class="fragment highlight-fl" data-fragment-index="1" -->ok about information retrieval
                    2. <!-- .element: class="fragment fade-in-then-out" data-fragment-index="2" -->a<span>␣boo</span><!-- .element: class="fragment highlight-fl" data-fragment-index="2" -->k about information retrieval
                    3. <!-- .element: class="fragment" data-fragment-index="3" -->a <span>book</span><!-- .element: class="fragment highlight-fl" data-fragment-index="3" --> about information retrieval <span>&rarr; Match</span><!-- .element: class="fragment" style="color: green;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Generate result lists

                For every query term in every document

                ## Query
                ```
                (information AND retrieval) OR search
                ```

                #### Query terms

                1. *information*
                2. *retrieval*
                3. *search*

                ## Documents

                1. *a book about information retrieval*
                2. *a book about the search for information*
                3. *a book about information*

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Generate result lists

                **Query term: *information*** &rarr; [#1, #2, #3]

                1. *a book about <span>information</span><!-- .element: class="highlight-fl" --> retrieval*
                2. *a book about the search for <span>information</span><!-- .element: class="highlight-fl" -->*
                3. *a book about <span>information</span><!-- .element: class="highlight-fl" -->*

                **Query term: *retrieval*** &rarr; [#1]

                1. *a book about information <span>retrieval</span><!-- .element: class="highlight-fl" -->*
                2. *a book about the search for information*
                3. *a book about information*

                **Query term: *search*** &rarr; [#2]

                1. *a book about information retrieval*
                2. *a book about the <span>search</span><!-- .element: class="highlight-fl" --> for information*
                3. *a book about information*

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Intersect / Union

                    * <!-- .element: class="fragment" data-fragment-index="1" --> \#1: _a book about information retrieval_
                    * <!-- .element: class="fragment" data-fragment-index="1" --> \#2: _a book about the search for information_
                    * <!-- .element: class="fragment" data-fragment-index="1" --> \#3: _a book about information_

                    ```
                    (information AND retrieval) OR search
                    ```
                    <!-- .element: class="fragment" data-fragment-index="1" -->

                    ![...](images/grep.png) <!-- .element: class="fragment" data-fragment-index="2" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Complexity

                    ## Grep

                    Search every query term as a string in every document: <!-- .element: class="fragment" -->

                    &Omicron;(num query terms &times; total length of all documents) <!-- .element: class="fragment" -->

                    ## Union

                    Merge result lists: <!-- .element: class="fragment" -->

                    &Omicron;(1) <!-- .element: class="fragment" -->

                    ## Intersect

                    Compare every result from one list with every result from the other: <!-- .element: class="fragment" -->

                    &Omicron;(query term with highest number of matches) <!-- .element: class="fragment" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Grep complexity

                    * &Omicron;(num query terms &times; total length of all documents)
                    * Can take really long

                    ## <!-- .element: class="fragment" data-fragment-index="1" --> Example

                    * <!-- .element: class="fragment" data-fragment-index="1" -->*English Wikipedia*: 5M articles, 10B characters, 1M distinct terms
                    * <!-- .element: class="fragment" data-fragment-index="1" -->grep: 2 query terms &times; 10GB = **20 billion string comparisons**

                    Notes:
                    How can this be improved?
                </script>
            </section>
        </section>

        <section id="term_document_matrix_section">
            <section id="term_document_matrix" data-markdown>
                <script type="text/template" data-separator-notes="^Notes:">
                    # Term-document Matrix

                    Reduce time complexity of `grep` operation

                    * Aka _incidence matrix_
                    * Rows: Distinct query terms
                    * Columns: Documents
                    * Fields: If term in doc 1, else 0
                    * Needs to pre-processed
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * \#1: _a book about information retrieval_
                    * \#2: _a book about the search for information_
                    * \#3: _a book about information_

                    ***

                    |             | #1 | #2 | #3 |
                    |-------------|----|----|----|
                    | **Book**        | 1<!-- .element: class="fragment" data-fragment-index="1" -->  | 1<!-- .element: class="fragment" data-fragment-index="5" -->  | 1<!-- .element: class="fragment" data-fragment-index="9" -->  |
                    | **Information** | 1<!-- .element: class="fragment" data-fragment-index="2" -->  | 1<!-- .element: class="fragment" data-fragment-index="6" -->  | 1<!-- .element: class="fragment" data-fragment-index="10" -->  |
                    | **Retrieval**   | 1<!-- .element: class="fragment" data-fragment-index="3" -->  | 0<!-- .element: class="fragment" data-fragment-index="7" -->  | 0<!-- .element: class="fragment" data-fragment-index="11" -->  |
                    | **Search**      | 0<!-- .element: class="fragment" data-fragment-index="4" -->  | 1<!-- .element: class="fragment" data-fragment-index="8" -->  | 0<!-- .element: class="fragment" data-fragment-index="12" -->  |

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    |             | #1 | #2 | #3 |
                    |-------------|----|----|----|
                    | Book        | 1  | 1  | 1  |
                    | Information | 1  | 1  | 1  |
                    | Retrieval   | 1  | 0  | 0  |
                    | Search      | 0  | 1  | 0  |

                    ***

                    * Document vector
                        * <!-- .element: class="fragment" --> \#1: `(1, 1, 1, 0)`
                    * Term vector
                        * <!-- .element: class="fragment" --> _Retrieval_: `(1, 0, 0)`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How to query

                    Replace every term in query with term vector

                    * (information AND retrieval) OR search
                    * = (111 &and; 100) &or; 010 <!-- .element: class="fragment" -->
                    * = 100 &or; 010 <!-- .element: class="fragment" -->
                    * = 110 <!-- .element: class="fragment" -->
                    * = \#1 and \#2 <!-- .element: class="fragment" -->
                        * <!-- .element: class="fragment" --> \#1: _a book about information retrieval_
                        * <!-- .element: class="fragment" --> \#2: _a book about the search for information_

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    #  Time complexity

                    &Omicron;(num query terms &times; num distinct terms)<!-- .element: class="fragment" data-fragment-index="1" -->

                    ## <!-- .element: class="fragment" data-fragment-index="2" -->Example

                    * <!-- .element: class="fragment" data-fragment-index="2" -->*English Wikipedia*: 5M articles, 10B characters, 1M distinct terms
                    * <!-- .element: class="fragment" data-fragment-index="2" -->grep: 2 query terms &times; 10GB = **20 billion string comparisons**
                    * <!-- .element: class="fragment" data-fragment-index="3" -->Term-Document Matrix: 2 query terms &times; 1M distinct terms = **2M lookups**

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Size

                    num(distinct terms) &times; num(docs) bits<!-- .element: class="fragment" data-fragment-index="1" -->

                    ## <!-- .element: class="fragment" data-fragment-index="2" -->Example

                    * <!-- .element: class="fragment" data-fragment-index="2" -->*English Wikipedia*: 5M articles, 10B characters, 1M distinct terms
                    * <!-- .element: class="fragment" data-fragment-index="2" -->1M distinct terms &times; 5M articles = 5.000.000.000.000 cells = **5 terrabit**

                    That's way too large! How can the size be decreased?<!-- .element: class="fragment" data-fragment-index="2" -->

                    &darr;<!-- .element: class="fragment" data-fragment-index="4" -->

                    <!-- .element: class="fragment" data-fragment-index="4" -->Matrix is very sparse, has mostly zeros

                    Notes:
                    Audience question
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <!-- .element: class="stretch" --> ![...](images/buch-index.png)

                    Notes:
                </script>
            </section>

        </section>

        <section id="inverted_index_section">
            <section id="inverted_index" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Inverted index*

                    \* This will be your homework

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * Same information as Term-document Matrix, but
                    * Store only 1s = Term occurences
                    * Terms &rarr; List of docs

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * \#1: _a book about information retrieval_
                    * \#2: _a book about the search for information_
                    * \#3: _a book about information_

                    ***

                    | Term        | Doc IDs    |
                    |-------------|------------|
                    | Book        | #1, #2, #3 <!-- .element: class="fragment" --> |
                    | Information | #1, #2, #3 <!-- .element: class="fragment" --> |
                    | Retrieval   | #1         <!-- .element: class="fragment" --> |
                    | Search      | #2         <!-- .element: class="fragment" --> |

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## Vocabulary / Dictionary / Lexicon <!-- .element: class="fragment" data-fragment-index="1" -->
                    List of terms <!-- .element: class="fragment" data-fragment-index="1" -->

                    ## Posting <!-- .element: class="fragment" data-fragment-index="2" -->
                    Document which term occurs in <!-- .element: class="fragment" data-fragment-index="2" -->

                    ## Postings list <!-- .element: class="fragment" data-fragment-index="3" -->
                    All documents which term occurs in <!-- .element: class="fragment" data-fragment-index="3" -->

                    ## Postings <!-- .element: class="fragment" data-fragment-index="4" -->
                    All postings lists <!-- .element: class="fragment" data-fragment-index="4" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Index time

                    1. Extract terms from docs
                    2. Sort vocabulary alphabetically
                    3. Sort postings lists by document ID

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query time

                    1. Look up each query term in vocabulary
                    2. Retrieve postings
                    3. Intersect / Union

                    *Only exact terms can be found!*

                    Notes:
                    Why can only exact terms be found?
                </script>
            </section>

            <section>
                <table>
                    <tr>
                        <th>Term</th>
                        <th>Doc IDs</th>
                    </tr>
                    <tr>
                        <td>Book</td>
                        <td>#1, #2, #3</td>
                    </tr>
                    <tr class="fragment highlight-fl" data-fragment-index="2">
                        <td>Information</td>
                        <td>#1, #2, #3</td>
                    </tr>
                    <tr>
                        <td>Retrieval</td>
                        <td>#1</td>
                    </tr>
                    <tr class="fragment highlight-fl" data-fragment-index="3">
                        <td>Search</td>
                        <td>#2</td>
                    </tr>
                </table>

                <hr/>

                <p class="fragment" data-fragment-index="1"><strong>Query</strong>:
                    <span class="fragment highlight-fl" data-fragment-index="2">
                        Information
                    </span>
                    <span>AND</span>
                    <span class="fragment highlight-fl" data-fragment-index="3">
                        Search
                    </span>
                </p>

                <p class="fragment fade-in" data-fragment-index="4">
                    (#1, #2, #3) AND (#2)
                </p>


                <h3 class="fragment fade-in" data-fragment-index="5">
                    &rarr; #2
                </h3>

                <aside class="notes">
                    Audience question
                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Time complexity

                    &Omicron;(num query terms &times; num distinct terms)<!-- .element: class="fragment" data-fragment-index="1" -->

                    ## <!-- .element: class="fragment" data-fragment-index="1" -->Example

                    * <!-- .element: class="fragment" data-fragment-index="1" -->*English Wikipedia*: 5M articles, 10B characters, 1M distinct terms
                    * <!-- .element: class="fragment" data-fragment-index="1" -->Term-Document Matrix: 2 query terms &times; 1M distinct terms = **2M lookups**
                    * <!-- .element: class="fragment" data-fragment-index="2" -->Inverted Index: 2 query terms &times; 1M distinct terms = **2M lookups**
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ## Size

                    &Omicron;(num distinct terms &times; average postings list length)<!-- .element: class="fragment" data-fragment-index="1" -->

                    ## <!-- .element: class="fragment" data-fragment-index="2" -->Example

                    * <!-- .element: class="fragment" data-fragment-index="2" -->*English Wikipedia*: 5M articles, 10B characters, 1M distinct terms
                    * <!-- .element: class="fragment" data-fragment-index="2" -->Term-Document Matrix: 1M distinct terms &times; 5M articles = 5.000.000.000.000 cells = **5 terrabit**
                    * <!-- .element: class="fragment" data-fragment-index="3" -->Inverted Index: 1M distinct terms &times; 10K postings per terms &times; 4 bytes per document ID = 40.000.000.000 bytes = **40 gigabytes**
                </script>
            </section>

            <!--section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    TODO: Intersect algorithm

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * Keep vocabulary in memory
                    * Postings may be swapped out

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ## Why?

                    * Support ad-hoc retrieval
                    * Support more operators, such as `NEAR`
                    * Support ranked retrieval

                    Notes:
                </script>
            </section-->
        </section>

        <section id="homework_inverted_index_section">
            <section id="homework_inverted_index" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Homework

                    Implement boolean retrieval using inverted index

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ```
                    Enter query, empty to quit:

                    ? this text
                    ['resources/1.txt', 'resources/2.txt', 'resources/3.txt']

                    Enter query, empty to quit:

                    ? another Text
                    ['resources/2.txt']

                    Enter query, empty to quit:

                    ? Words
                    ['resources/1.txt']

                    Enter query, empty to quit:

                    ? blubbergurken
                    []

                    Enter query, empty to quit:

                    ? blubbergurken text
                    []

                    Enter query, empty to quit:
                    ?
                    ```
                    <!-- .element: class="stretch" -->

                    Notes:
                </script>
            </section>
            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Homework

                    * Built **Inverted Index** from text files
                    * [Use the provided setup](https://gitlab.mediacube.at/information-retrieval/homework-1-inverted-index), make sure to read `README.md`
                    * Read `resources/*.txt`
                        * Just once during start up, not for every query
                    * Query using implicit AND (`this text` &rarr; `this AND text`)
                    * Your application should be able to handle millions of files efficiently
                    * Use the provided CLI to manually test your application (see `README.md`)
                    * Ensure that the provided test cases run successfully (see `README.md`)

                    Notes:
                </script>
            </section>
        </section>

        <section id="tokenization_section">
            <section id="tokenization" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Tokenization

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Tokenization

                    > a book about information retrieval <!-- .element: class="fragment" data-fragment-index="1" -->

                    &darr; <!-- .element: class="fragment" data-fragment-index="2" -->

                    `[a, book, about, information, retrieval]` <!-- .element: class="fragment" data-fragment-index="2" -->

                    > "Information Retrieval": Also available as e-book! <!-- .element: class="fragment" data-fragment-index="3" -->

                    &darr; <!-- .element: class="fragment" data-fragment-index="4" -->

                    `[Information Retrieval]? [Information, Retrieval]?` <!-- .element: class="fragment" data-fragment-index="4" -->

                    `[e-book]? [eBook]? [e, book]?` <!-- .element: class="fragment" data-fragment-index="4" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Challenge

                    Inverted index can only find exact tokens

                    | Term        | Doc IDs    |
                    |-------------|------------|
                    | book        | #1, #2, #3  |
                    | information | #1, #2, #3  |
                    | retrieval   | #1          |
                    | search      | #2          |

                     _e-book_ will return no results!

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Challenge

                    * <!-- .element: class="fragment" --> How can _books_ find _book_?
                    * <!-- .element: class="fragment" --> _wi-fi_  &leftrightarrow; _wifi_?
                    * <!-- .element: class="fragment" --> _Jack's_  &leftrightarrow; _Jack_?
                    * <!-- .element: class="fragment" --> _MMT_ &leftrightarrow; _Multimediatechnology_?
                    * <!-- .element: class="fragment" --> _U.S.A._ &leftrightarrow; _USA_?

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Text analysis

                    * Analyse docs and query
                    * Add, remove, change terms

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## Token <!-- .element: class="fragment" data-fragment-index="1" -->
                    * Character sequence, meaningful semantic unit <!-- .element: class="fragment" data-fragment-index="1" -->
                    * No analysis yet <!-- .element: class="fragment" data-fragment-index="1" -->
                    * <!-- .element: class="fragment" data-fragment-index="1" --> _the_, _routers_

                    ## Type <!-- .element: class="fragment" data-fragment-index="2" -->
                    * Distinct tokens, same token counts only once <!-- .element: class="fragment" data-fragment-index="2" -->
                    * <!-- .element: class="fragment" data-fragment-index="2" --> _the_, _routers_

                    ## Terms <!-- .element: class="fragment" data-fragment-index="3" -->
                    * Index tokens <!-- .element: class="fragment" data-fragment-index="3" -->
                    * <!-- .element: class="fragment" data-fragment-index="3" --> _router_
                </script>
            </section>

        </section>

        <section id="stop_words_section">
            <section id="stop_words" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stop Words

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stop words

                    * Add no meaning: *table* should find *a table* and * the table*
                    * Inflate index size
                    * Manually curated list
                    * [Default english stop words for Solr](https://github.com/apache/lucene-solr/blob/master/solr/example/files/conf/lang/stopwords_en.txt)
                    * Start with top terms in collection
                    * Can be domain-specific
                    * Eg. *doctor*, *patient* in medical documents

                    Notes:
                    * What could be the problem with stop words?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stop words, but...

                    * *The Police* will find *police car*
                    * *The President of Austria* will find *President of United States visits Austria*
                    * *To be or not to be* will find everything / nothing

                    Notes:
                    * How to handle this better?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stop words in real life

                    * Index size not an issue anymore
                    * Solr: Stop words are optional, but increase score
                    * *The Police* will find *police car*, but rank *The Police* higher
                    * No special handling when query consists only of stopwords
                    * *To be or not to be* searches for `[to, be, or, not]`

                    Notes:
                </script>
            </section>
        </section>

        <section id="stemming_section">
            <section id="stemming" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stemming

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Stemming

                    * Reduce word endings to find common stem:
                        * *housing*, *houses*, *house* &rarr; *hous*
                    * Heuristic approach, not linguistic
                    * May find common stem for unrelated words:
                        * *organization*, *organs* &rarr; *organ*

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Porter Stemmer

                    Implemented in Snowball Stemming DSL

                    ## Step 1 of 5

                    | Match | Replace | Example |
                    |-------|---------|------------------------------------|
                    | SSES | SS | caresses &rarr; caress |
                    | IES | I |  ponies &rarr; poni, ties &rarr; ti |
                    | SS | SS  | caress &rarr; caress |
                    | S | <empty> | cats &rarr; cat |

                    … and so on

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Lemmatization

                    * Determine root based on linguistic rules
                    * Keeps type of word:
                        * *A saw* &rarr; *saw*, *I saw* &rarr; *see*
                    * Can generate inflections, eg. what's the plural of *house*?
                    * Benefits of lemmatization over stemming doubtful

                    Notes:
                </script>
            </section>
        </section>

        <section id="tokenization_example_section">

            <section id="tokenization_example" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Tokenization Example

                    Notes:
                </script>
            </section>

            <section>
                <table class="stretch">
                    <tr>
                        <th style="border-right: 1px solid rgb(34, 34, 34);"></th>
                        <th colspan="7" style="border-right: 1px solid rgb(34, 34, 34);">Index</th>
                        <th colspan="2">Query</th>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);"></td>
                        <td colspan="7" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="1">A Wi-Fi Router</span>
                        </td>
                        <td colspan="2"><span class="fragment" data-fragment-index="1">wireless routers</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Tokenization</td>
                        <td><span class="fragment" data-fragment-index="2">A</span></td>
                        <td><span class="fragment" data-fragment-index="2">Wi-Fi</span></td>
                        <td colspan="5" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="2">Router</span>
                        </td>
                        <td><span class="fragment" data-fragment-index="9">wireless</span></td>
                        <td><span class="fragment" data-fragment-index="9">routers</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Lowercasing</td>
                        <td><span class="fragment" data-fragment-index="4">a</span></td>
                        <td><span class="fragment" data-fragment-index="4">wi-fi</span></td>
                        <td colspan="5" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="4">router</span>
                        </td>
                        <td><span class="fragment" data-fragment-index="10">wireless</span></td>
                        <td><span class="fragment" data-fragment-index="10">routers</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Stop words</td>
                        <td></td>
                        <td><span class="fragment" data-fragment-index="5">wi-fi</span></td>
                        <td colspan="5" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="5">router</span>
                        </td>
                        <td><span class="fragment" data-fragment-index="11">wireless</span></td>
                        <td><span class="fragment" data-fragment-index="11">routers</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Word delimiter<br>(Index only)</td>
                        <td></td>
                        <td><span class="fragment" data-fragment-index="6">wi-fi</span></td>
                        <td><span class="fragment" data-fragment-index="6">wi</span></td>
                        <td><span class="fragment" data-fragment-index="6">fi</span></td>
                        <td><span class="fragment" data-fragment-index="6">wifi</span></td>
                        <td colspan="2" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="6">router</span>
                        </td>
                        <td><span class="fragment" data-fragment-index="12">wireless</span></td>
                        <td><span class="fragment" data-fragment-index="12">routers</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Stemming</td>
                        <td></td>
                        <td><span class="fragment" data-fragment-index="7">wi-fi</span></td>
                        <td><span class="fragment" data-fragment-index="7">wi</span></td>
                        <td><span class="fragment" data-fragment-index="7">fi</span></td>
                        <td><span class="fragment" data-fragment-index="7">wifi</span></td>
                        <td colspan="2" style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                               data-fragment-index="7">router</span>
                        </td>
                        <td><span class="fragment" data-fragment-index="13">wireless</span></td>
                        <td><span class="fragment" data-fragment-index="13">router</span></td>
                    </tr>
                    <tr>
                        <td style="border-right: 1px solid rgb(34, 34, 34);">Synonyms<br>wifi &rarr; wireless<br>(Index
                            only)
                        </td>
                        <td></td>
                        <td><span class="fragment" data-fragment-index="8">wi-fi</span></td>
                        <td><span class="fragment" data-fragment-index="8">wi</span></td>
                        <td><span class="fragment" data-fragment-index="8">fi</span></td>
                        <td><span class="fragment" data-fragment-index="8">wifi</span></td>
                        <td><span class="fragment" data-fragment-index="8">
                            <span class="fragment highlight-fl" data-fragment-index="15">wireless</span>
                        </span></td>
                        <td style="border-right: 1px solid rgb(34, 34, 34);"><span class="fragment"
                                                                                   data-fragment-index="8">
                            <span class="fragment highlight-fl" data-fragment-index="15">router</span>
                        </span></td>
                        <td><span class="fragment" data-fragment-index="14">
                            <span class="fragment highlight-fl" data-fragment-index="15">wireless</span>
                        </span></td>
                        <td><span class="fragment" data-fragment-index="14">
                            <span class="fragment highlight-fl" data-fragment-index="15">router</span>
                        </span></td>
                    </tr>
                </table>

                <aside class="notes">
                    Will increase relevance, but reduce precision
                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ![analysis](images/analysis.png)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Outcome

                    * <!-- .element: class="fragment" --> Find more results: _wireless_ &rarr; _wi-fi_
                    * <!-- .element: class="fragment" --> Find more imprecise results: _wi-fi_ &rarr; _wireless_
                    * <!-- .element: class="fragment" --> Miss some results: _to be or not to be_

                    Notes:
                    * Will this find more results?
                    * Will this find less accurate results?
                </script>
            </section>

        </section>

        <section id="precision_recall_section">
            <section id="precision_recall" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Precision & Recall

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Precision

                    * Are all results relevant?

                    Notes:
                </script>
            </section>
            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Recall

                    * Are all relevant documents in the results?

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ![precision-recall](images/precision-recall.png)

                    Notes:
                    * Am Whiteboard machen?
                    * How to evaluate?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Evaluation

                    * Requires human effort
                    * Annotated corpus:

                    ----

                    | Information Need | iPhone X | Galaxy S10 | Cover for Galaxy S10 | Battery Pack |
                    |-------------------------------------------|----------|------------|----------------------|--------------|
                    | smartphone | ✓ | ✓ | - | - |
                    | apple smartphone | ✓ | - | - | - |
                    | smartphone accessory | - | - | ✓ | ✓ |

                    ----

                    * Augment with click-stream logs

                    Notes:

                    * Audience participation
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Precision & Recall

                    * <!-- .element: class="fragment" --> Will never be 100% both
                    * <!-- .element: class="fragment" --> Rank results according to relevance

                    Notes:
                    * How to achieve 100% recall?
                    * How to achieve 100% precision?
                </script>
            </section>
        </section>

        <section id="ranked_retrieval_section">
            <section id="ranked_retrieval" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Ranked retrieval

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Idea I

                    ### <!-- .element: class="fragment" --> Multiple matches for query term = more important document

                    <blockquote class="fragment">A shop where **books** are bought and sold is a **book**shop or
                        **book**store. **Books** can also be borrowed from libraries.
                    </blockquote>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Idea II

                    ### <!-- .element: class="fragment" --> Infrequent terms in corpus are more important
                    <!-- .element: class="fragment" --> `apple iphone` &rarr; `iphone` more important than `apple` when searching apple.com


                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # I: Term frequency

                    ### <!-- .element: class="fragment" --> At index time:

                    * <!-- .element: class="fragment" --> Count term occurrences per doc
                    * <!-- .element: class="fragment" --> Ignore order of terms
                    * <!-- .element: class="fragment" --> _Bag of words_

                    <!-- .element: class="fragment" --> ![Tag cloud](https://upload.wikimedia.org/wikipedia/commons/5/5b/Word_Cloud_Readers_Survey.jpg)

                    Notes:
                    * Where to save TF info?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # TF

                    * \#1: _a book providing information about information retrieval_
                    * \#2: _a book about the search for books_
                    * \#3: _a book about information_

                    ***

                    | Term        | Doc IDs    |
                    |-------------|------------|
                    | Book        | #1:1, #2:2, #3:1 <!-- .element: class="fragment" --> |
                    | Information | #1:2, #3:1 <!-- .element: class="fragment" --> |
                    | Retrieval   | #1:1         <!-- .element: class="fragment" --> |
                    | Search      | #2:1         <!-- .element: class="fragment" --> |

                    Notes:
                    * Audience participation
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # TF pitfalls

                    * <!-- .element: class="fragment" --> Not always true
                    * <!-- .element: class="fragment" --> The Bible does not contain "_the bible_"
                    * <!-- .element: class="fragment" --> Web spam
                    * <!-- .element: class="fragment" --> Long documents have higher TF

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # II: Inverse document frequency

                    * <!-- .element: class="fragment" --> Searching apple.com for `apple OR iphone`
                        * fewer documents with `iphone` than `apple`
                        * `iphone` more important
                    * <!-- .element: class="fragment" --> Rank uncommon terms higher
                    * <!-- .element: class="fragment" --> Only relevant for OR search
                    * <!-- .element: class="fragment" --> Store value per term

                    Notes:
                    * Why is it only relevant for OR search?
                    * Why is it stored per term?
                </script>
            </section>

            <section>
                <h1>Inverse Document Frequency</h1>
                $$\text{idf}(\text{term}) = \frac{\text{num_docs}}{\text{document_frequency}(\text{term})}$$

                <h2>Example</h2>
                \[\begin{aligned}
                \text{idf}(\text{apple}) & = \frac{10}{9} & = 1.1 \\
                \text{idf}(\text{iphone}) & = \frac{10}{2} & = 5
                \end{aligned} \]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # IDF

                    * \#1: _a book providing information about information retrieval_
                    * \#2: _a book about the search for books_
                    * \#3: _a book about information_

                    ***

                    | Term        | IDF | Doc IDs    |
                    |-------------|------------|
                    | Book        | 1  <!-- .element: class="fragment" --> | #1:1, #2:2, #3:1 |
                    | Information | 1.5<!-- .element: class="fragment" --> | #1:2, #3:1  |
                    | Retrieval   | 3  <!-- .element: class="fragment" --> | #1:1          |
                    | Search      | 3  <!-- .element: class="fragment" --> | #2:1          |

                    Notes:

                    * idf(t) = 1 is special case
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # TF-IDF Ranking

                    $$\text{score}(\text{query}, \text{document}) = \sum_{\text{term} \in \text{query}} \left( \text{tf}(\text{term}, \text{document}) \times \text{idf}(\text{term}) \right)$$

                    Notes:
                    * Explain formula in human-speak.
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    | Term        | IDF | Doc IDs    |
                    |-------------|------------|
                    | Book        | 1   | #1:1, #2:2, #3:1 |
                    | Information | 1.5 | #1:2, #3:1  |
                    | Retrieval   | 3   | #1:1          |
                    | Search      | 3   | #2:1          |

                    ```
                    information retrieval search
                    ```

                    ### \#1 <!-- .element: class="fragment" -->

                    2 &times; 1.5 + 1 &times; 3 + 0 &times; 3 = 6 <!-- .element: class="fragment" -->

                    ### \#2 <!-- .element: class="fragment" -->

                    0 &times; 1.5 + 0 &times; 3 + 1 &times; 3 = 3 <!-- .element: class="fragment" -->

                    ### \#3 <!-- .element: class="fragment" -->

                    1 &times; 1.5 + 0 &times; 3 + 0 &times; 3 = 1.5 <!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Meanwhile in the real world...

                    * Solr default is now [Okapi BM25](https://en.wikipedia.org/wiki/Okapi_BM25)
                    * Also based on TF-IDF
                    * Much less descriptive:

                    $${\displaystyle {\text{score}}(D,Q)=\sum_{i=1}^{n}{\text{IDF}}(q_i)\cdot {\frac {TF(q_i,D)\cdot (k_1+1)}{TF(q_i,D)+k_1\cdot \left(1-b+b\cdot {\frac {|D|}{\text{avgdl}}}\right)}}}$$ <!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>
        </section>

        <section id="phrase_queries_section">
            <section id="phrase_queries" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Phrase queries

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Phrase queries

                    * <!-- .element: class="fragment" --> Search for names and concepts: `"fh salzburg"`, `"mountain bike"`
                    * <!-- .element: class="fragment" --> Well accepted by users
                    * <!-- .element: class="fragment" --> But: `"fh salzburg"` should not match *In Salzburg there is a University and a FH*
                    * <!-- .element: class="fragment" --> Needs more advanced index with positional information

                    Notes:
                    * How could we implement this?
                    * Can the current index handle this?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Positional index

                    * \#1: _retrieving more information about information retrieval_
                    * \#2: _searching and retrieving a book about the search for information_
                    * \#3: _a book about information_

                    ***

                    | Terms (no stopwords)        | Doc IDs    |
                    |-------------|------------|
                    | book        | #2:[3], #3:[1] <!-- .element: class="fragment" --> |
                    | information | #1:[2, 3], #2:[5], #3:[2] <!-- .element: class="fragment" --> |
                    | retriev     | #1:[1, 4], #2:[2]         <!-- .element: class="fragment" --> |
                    | search      | #2:[1, 4]         <!-- .element: class="fragment" --> |

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Intersection algorithm

                    `"information retrieval"`

                    1. <!-- .element: class="fragment" --> Fetch postings for each query term:
                        * <!-- .element: class="fragment" --> *information*: #1:[2, 3], #2:[5], #3:[2]
                        * <!-- .element: class="fragment" --> *retriev*: #1:[1, 4], #2:[2]
                    2. <!-- .element: class="fragment" --> Calculate term pair distances per document, eg. `retrieval - information`:
                        * <!-- .element: class="fragment" --> _#1: retrieving more information about information retrieval_ &rarr; _retrieval_:[1, 4] - _information_:[2, 3]
                            * <!-- .element: class="fragment" --> [**1**, <span style="color: lightgray;">4</span>] - [**2**, <span style="color: lightgray;">3</span>] = -1 != 1
                            * <!-- .element: class="fragment" --> [**1**, <span style="color: lightgray;">4</span>] - [<span style="color: lightgray;">2</span>, **3**] = -2 != 1
                            * <!-- .element: class="fragment" --> [<span style="color: lightgray;">1</span>, **4**] - [**2**, <span style="color: lightgray;">3</span>] = 2 != 1
                            * <!-- .element: class="fragment" --> [<span style="color: lightgray;">1</span>, **4**] - [<span style="color: lightgray;">2</span>, **3**] = 1 &rarr; match
                                * <!-- .element: class="fragment" --> #1: retrieving more information about *information retrieval*
                        * <!-- .element: class="fragment" --> _searching and retrieving a book about the search for information_ &rarr; _retrieval_:[2] - _information_:[5]
                            * <!-- .element: class="fragment" --> [**2**] - [**5**] = -3 != 1

                    Notes:
                    * Can this used proximity regardless of order, eg. match "retrieval information" as well?
                    * Can this support phrase gaps, ie. `information … retrieval`?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Positional index

                    Supports phrase gaps: `"dwayne johnson"~2` matches *dwayne the rock johnson*

                    Notes:
                    * The most common case is to search for two consecutive words. The intersection algorithm is a bit expensive. Can we speed this up?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Biword index

                    * Speed up common phrase queries
                    * Auxiliary index
                    * Index term pairs
                    * Fast lookup of term pairs

                    #1: "Study at FH Salzburg"

                    &darr;


                    | Term        | Doc IDs |
                    |-------------|---------|
                    | study at    | #1      |
                    | at fh       | #1      |
                    | fh salzburg | #1      |

                    Notes:
                </script>
            </section>
        </section>

        <section id="vocabulary_structure_section">
            <section id="vocabulary_structure" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vocabulary structure

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vocabulary structure

                    * <!-- .element: class="fragment" --> Dictionary / Hash table
                    * <!-- .element: class="fragment" --> Search tree

                    Notes:
                    * Suggestions?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Hash table

                    ![hash table](images/hash-table.svg) <!-- .element: class="stretch" style="width: 50%;" -->

                    <!-- .element: style="font-size: small;" --> By Jorge Stolfi - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=6471238

                    Notes:
                    * What is the complexity of lookup / insert? Does it get slower with more entries?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Hash table

                    * \+ Fast lookup: &Omicron;(1)
                        * Calculate hash, follow pointer
                    * \+ Fast insert: &Omicron;(1)
                    * \- Hash collisions
                        * Worst case complexity: &Omicron;(n)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Hash table collision

                    ![hash table collision](images/hash-table-collision.svg) <!-- .element: class="stretch" style="width: 60%;" -->

                    <!-- .element: style="font-size: small;" --> By Jorge Stolfi - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=6472274

                    Extra lookup necessary when hashes collide. Worst case &Omicron;(n)

                    Notes:
                </script>
            </section>

            <section>
                <h1>Search Tree</h1>

                <script class="tree" type="application/json">
                    {
                        "name": "<root>",
                        "children": [
                            {
                                "name": "A-M",
                                "children": [
                                    {
                                        "name": "Austria"
                                    },
                                    {
                                        "name": "China"
                                    }
                                ]
                            },
                            {
                                "name": "N-Z",
                                "children": [
                                    {
                                        "name": "Norway"
                                    },
                                    {
                                        "name": "Russia"
                                    }
                                ]
                            }
                        ]
                    }
                </script>

                <aside class="notes">
                    What is the lookup / insert complexity? Does it get slower with more entries? How much? Ο(log n)
                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Search Tree

                    * \+ Fast lookup: &Omicron;(log n)
                        * Average height of tree
                    * \+ Fast insertion: &Omicron;(log n)
                    * \+ Supports prefix search
                    * Different type of tree used depending on use case
                        * Eg. Binary Tree (in-memory), B-Tree (on disk)

                    Notes:
                </script>
            </section>
        </section>

        <section id="wildcard_queries_section">
            <section id="wildcard_queries" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Wildcard queries

                    *Apple i**

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Wildcard queries

                    Expand query:

                    `i*`

                    &darr;

                    | Term | Documents |
                    |--------|------------|
                    | galaxy | #2, #4 |
                    | **iphone** | #2, #3 |
                    | **ipad** | #2, #3, #4 |
                    | lumia | #1 |

                    &darr;

                    `iphone OR ipad`

                    Notes:
                    * How to get prefix queries, ie. `salz*`? Think of search tree.
                </script>
            </section>

            <section>
                <h1>salz*</h1>

                <p>Comes free with search tree</p>

                <script class="tree" type="application/json">
                    {
                        "name": "S",
                        "children": [
                            {
                                "name": "SA",
                                "children": [
                                    {
                                        "name": "SAL",
                                        "children": [
                                            {
                                                "name": "Salzburg",
                                                "fill": "#ff8c00"
                                            },
                                            {
                                                "name": "Salzach",
                                                "fill": "#ff8c00"
                                            }
                                        ]
                                    },
                                    {
                                        "name": "…"
                                    }
                                ]
                            },
                            {
                                "name": "…"
                            }
                        ]
                    }
                </script>

                <aside class="notes">
                    How to get suffix search, ie. `*burg`?
                </aside>
            </section>

            <section>
                <h1>*burg</h1>

                <p>Build index with reversed terms</p>

                <script class="tree" type="application/json">
                    {
                        "name": "G",
                        "children": [
                            {
                                "name": "GR",
                                "children": [
                                    {
                                        "name": "GRU",
                                        "children": [
                                            {
                                                "name": "grubzlas",
                                                "fill": "#ff8c00"
                                            },
                                            {
                                                "name": "grubierf",
                                                "fill": "#ff8c00"
                                            }
                                        ]
                                    },
                                    {
                                        "name": "…"
                                    }
                                ]
                            },
                            {
                                "name": "…"
                            }
                        ]
                    }
                </script>

                <aside class="notes">
                    How to get infix search, ie. `sal*urg`?
                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # `sal*urg`

                    Intersect results of `sal*` and `*urg`

                    Notes:

                </script>
            </section>



            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # N-gram queries

                    <!-- .element: class="fragment" --> `search`

                    <!-- .element: class="fragment" --> &darr; (3-gram)

                    <!-- .element: class="fragment" --> $`se, sea, ear, arc, rch, ch`$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # N-gram index

                    |   | Term | Doc IDs |
                    |---|------|---------|
                    |   | $se  | 1, 2, 3 |
                    |   | arc  | 1       |
                    |   | ch$  | 1, 8    |
                    |   | ear  | 1, 7    |
                    |   | rch  | 1       |
                    |   | sea  | 1, 5, 9 |

                    Notes:
                    * Can the original contents be reconstructed from the index?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # N-gram queries

                    <!-- .element: class="fragment" --> Expand query

                    <!-- .element: class="fragment" --> `sea*`

                    <!-- .element: class="fragment" --> &darr;

                    <!-- .element: class="fragment" --> `$se AND sea`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # N-gram queries

                    `$se AND sea`

                    |   | Term | Doc IDs |
                    |---|------|---------|
                    |   | $se <!-- .element: class="fragment highlight-fl" data-fragment-index="1" -->  | <span>1</span><!-- .element: class="fragment highlight-fl" data-fragment-index="3" -->, 2, 3 |
                    |   | arc  | 1       |
                    |   | ch$  | 1, 8    |
                    |   | ear  | 1, 7    |
                    |   | rch  | 1       |
                    |   | sea <!-- .element: class="fragment highlight-fl" data-fragment-index="2" --> | <span>1</span><!-- .element: class="fragment highlight-fl" data-fragment-index="3" -->, 5, 9 |

                    Notes:
                </script>
            </section>
        </section>

        <section id="spelling_correction_section">
            <section id="spelling_correction" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Spelling correction

                    *Palystation, Xboy, Wiii*

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Spelling correction

                    ![iformmetoin](images/iformmetoin.png) <!-- .element: class="fragment" style="border: none;" -->

                    1. <!-- .element: class="fragment" --> Find alternatives
                    2. <!-- .element: class="fragment" --> Evaluate alternatives
                    3. <!-- .element: class="fragment" --> Return alternative results

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # 1. Find alternatives

                    <!-- .element: class="fragment" --> `bock`

                    <!-- .element: class="fragment" --> &darr;

                    <!-- .element: class="fragment" --> `book`, `rock`, `spock`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Find alternatives

                    * Compare query with vocabulary
                    * Use index or query log
                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Levenshtein

                    * Edit distance between two words
                    * Count inserts, deletes, replaces, swaps

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Levenshtein

                    <table>
                        <tr>
                            <td>iformmetoin~</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="fragment">1. Add **n**</span></td>
                            <td><span class="fragment">informmetoin</span></td>
                        </tr>
                        <tr>
                            <td><span class="fragment">2. Delete **m**</span></td>
                            <td><span class="fragment">informetoin</span></td>
                        </tr>
                        <tr>
                            <td><span class="fragment">3. Replace **e** with **a**</span></td>
                            <td><span class="fragment">informatoin</span></td>
                        </tr>
                        <tr>
                            <td><span class="fragment">4. Swap **o** and **i**</span></td>
                            <td><span>information</span></td>
                        </tr>
                    </table>

                    <div class="fragment">
                        <p>&darr;</p>
                        <p>Levenshtein distance = 4</p>
                    </div>

                    Notes:
                    * Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Levenshtein

                    * Weighted (keyboard distance)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Levenshtein

                    * Expensive: Cannot be precomputed
                    * `num(query terms) × num(vocabulary terms)`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # 2. Evaluate alternatives

                    * Isolated
                    * Context

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Isolated

                    * <!-- .element: class="fragment" --> `seach endine`?
                    * <!-- .element: class="fragment" --> &rarr; `peach engine`
                    * <!-- .element: class="fragment" --> &rarr; `search ending`
                    * <!-- .element: class="fragment" --> &rarr; `search engine`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Context

                    * <!-- .element: class="fragment" data-fragment-index="1" --> Find alternatives for every misspelled query term &rarr; collations
                    * <!-- .element: class="fragment" data-fragment-index="2" --> Search for collation and evaluate results

                    <hr class="fragment" data-fragment-index="3"/>

                    * <!-- .element: class="fragment" data-fragment-index="4" --> `seach endine`?
                    * <!-- .element: class="fragment" data-fragment-index="5" --> `seach` &rarr; `peach, search`
                    * <!-- .element: class="fragment" data-fragment-index="6" --> `endine` &rarr; `ending, engine`

                    <hr class="fragment" data-fragment-index="7"/>

                    * <!-- .element: class="fragment" data-fragment-index="8" --> `seach endine`?
                    * <!-- .element: class="fragment" data-fragment-index="9" --> &rarr; `peach engine`? 0 results
                    * <!-- .element: class="fragment" data-fragment-index="10" --> &rarr; `peach ending`? 0 results
                    <li class="fragment" data-fragment-index="11">&rarr; `search ending`
                        <!-- .element: class="fragment highlight-fl" data-fragment-index="13" --> ? 5 results
                    </li>
                    <li class="fragment" data-fragment-index="12">&rarr; `search engine`
                        <!-- .element: class="fragment highlight-fl" data-fragment-index="13" --> ? 10 results
                    </li>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Evaluate alternatives

                    * <!-- .element: class="fragment" --> Most results
                    * <!-- .element: class="fragment" --> Best results
                    * <!-- .element: class="fragment" --> Most searched

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # 3. Return alternative results

                    * Feedback
                    * Transparency

                    Notes:
                    * How does this affect precision and recall?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ![Did you mean](images/Did you mean.png)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ![Instead](images/Instead.png)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ![Showing results for](images/Showing results for.png)

                    Notes:
                </script>
            </section>
        </section>

        <section id="phonetic_correction_section">
            <section id="phonetic_correction" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Phonetic correction

                    *Meyer, Mayer, Maier?*

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Soundex

                    * <!-- .element: class="fragment" --> For proper names, brand names, drugs
                    * <!-- .element: class="fragment" --> Encode strings according to their sounds
                    * <!-- .element: class="fragment" --> `Meier` &rarr; `M600`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Index

                    | Term (not in index) | Soundex | Doc IDs |
                    |----------------------------|---------|---------|
                    | _<span class="fragment highlight-fl" data-fragment-index="3">meier</span>, maier, mayer, meyer_ |<span class="fragment highlight-fl" data-fragment-index="3">M600</span> | <span class="fragment highlight-fl" data-fragment-index="3">1, 3, 5</span> |
                    | _müller, mueller_ | M460 | 2, 4, 6 |
                    | _goethe, göthe_ | G300 | 7, 8, 9 |
                    <!-- .element: class="fragment" data-fragment-index="1" -->

                    # Query <!-- .element: class="fragment" data-fragment-index="2" -->

                    <p><span class="fragment" data-fragment-index="2">`Meier` &rarr; `M600`</span><span class="fragment"
                                                                                                        data-fragment-index="3">&rarr; 1, 3, 5</span>
                    </p>
                    <p><span class="fragment" data-fragment-index="4">`Maier` &rarr; `M600` &rarr; 1, 3, 5</span></p>

                    Notes:
                    * How does this affect precision and recall?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Result quality

                    * <!-- .element: class="fragment" data-fragment-index="1" -->Recall up
                    * <!-- .element: class="fragment" data-fragment-index="1" --> Precision down

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Soundex alternatives

                    * Daitch–Mokotoff Soundex
                    * Metaphone
                    * Double Metaphone

                    Notes:
                </script>
            </section>
        </section>



        <section id="homework_tf_idf_section">

            <section id="homework_tf_idf" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Homework

                    Implement TF-IDF scoring

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ```
                    Enter query, empty to quit: salzburg
                    Found 28 results, showing top 5

                    Archbishopric_of_Salzburg.txt: 39629.857142857145
                        salzburg: 39629.857142857145

                    Herbert_von_Karajan.txt: 10808.142857142857
                        salzburg: 10808.142857142857

                    Wolfgang_Amadeus_Mozart.txt: 10808.142857142857
                        salzburg: 10808.142857142857

                    Alfons_Schuhbeck.txt: 3602.714285714286
                        salzburg: 3602.714285714286

                    Carl_Maria_von_Weber.txt: 3602.714285714286
                        salzburg: 3602.714285714286
                    ```
                    <!-- .element: class="stretch" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    ```
                    Enter query, empty to quit: austria germany
                    Found 1713 results, showing top 5

                    Anschluss.txt: 3891.5421630618653
                        austria: 3729.5704225352115
                        germany: 161.97174052665383

                    Austria.txt: 3794.359118745873
                        austria: 3729.5704225352115
                        germany: 64.78869621066153

                    Germany.txt: 2686.44960062236
                        austria: 710.3943661971831
                        germany: 1976.0552344251766

                    Treaty_of_Versailles.txt: 2650.6333143368884
                        austria: 1775.9859154929577
                        germany: 874.6473988439307

                    Prussia.txt: 1858.6827548463548
                        austria: 1243.1901408450703
                        germany: 615.4926140012846
                    ```
                    <!-- .element: class="stretch" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Homework

                    * [Use the provided setup](https://gitlab.mediacube.at/information-retrieval/homework-2-tf-idf-scoring), make sure to read `README.md`
                    * Implement TF-IDF scoring
                        * This means **OR** search
                    * Use [simple-wikipedia.zip](files/simple-wikipedia.zip)
                    * Ensure that the provided test cases run successfully (see README.md)
                    * Use the provided CLI to manually test your application (see README.md)
                        * Displays top 5 results
                        * For each result show total score and per-term score
                            * The sum of all term scores must equal the total score
                    * Bonus points:
                        * Implement TF normalization
                        * Parallelize indexing
                        * Surprise me

                    Notes:
                </script>
            </section>
        </section>

        <section id="field_weights_section">
            <section id="field_weights" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Use document structure for ranking

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document structure

                    ![Document Structure](images/Document Structure.png)

                    Notes:
                    How can we exploit this information for ranking purposes?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Field weights

                ![Document Structure](images/Document Structure with Field Weights.png)

                Notes:
                How can we determine the field weights?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Index with Fields

                    | Doc | Author | Title |
                    |-----|-----------------|----------------------------------------------------------|
                    | #1 | Arthur McAuthor | A book providing information about information retrieval |
                    | #2 | Shakesbeer | A book about the search for King Arthur |

                    ***

                    | Term | Doc IDs |
                    |-------------|-------------------------------|
                    | arthur | #1:Author, #2:Title<!-- .element: class="fragment" --> |
                    | book | #1:Title, #2:Title<!-- .element: class="fragment" --> |
                    | information | #1:Title<!-- .element: class="fragment" --> |
                    | mcauthor | #1:Author<!-- .element: class="fragment" --> |
                    | shakesbeer | #2:Author<!-- .element: class="fragment" --> |
                    | ... |

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Field weights

                    | Term | Doc IDs |
                    |-------------|-------------------------------|
                    | <span class="fragment highlight-current-fl" data-fragment-index="3"><span class="fragment highlight-current-fl" data-fragment-index="5">arthur</span></span> | <span class="fragment highlight-current-fl" data-fragment-index="3">#1:Author</span>, <span class="fragment highlight-current-fl" data-fragment-index="5">#2:Title</span> |
                    | <span class="fragment highlight-current-fl" data-fragment-index="3"><span class="fragment highlight-current-fl" data-fragment-index="5">book</span></span> | <span class="fragment highlight-current-fl" data-fragment-index="3">#1:Title</span>, <span class="fragment highlight-current-fl" data-fragment-index="5">#2:Title</span> |
                    | ... |

                    ***

                    * `weight(author) = 10`
                    * `weight(title) = 1`

                    ***

                    * <!-- .element: class="fragment" data-fragment-index="1" --> `arthur book`?
                        * \#1 &rarr; <!-- .element: class="fragment" data-fragment-index="2" --> <span class="fragment" data-fragment-index="3"><span class="fragment highlight-current-fl" data-fragment-index="3">author + title = 10 + 1 = **11**</span></span>
                        * \#2 &rarr; <!-- .element: class="fragment" data-fragment-index="4" --> <span class="fragment" data-fragment-index="5"><span class="fragment highlight-current-fl" data-fragment-index="5">title + title = 1 + 1 = **2**</span></span>

                    Notes:
                    * Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Field weights

                    * Determining weights is hard
                    * Use annotated corpus and machine learning

                    Notes:
                    What else can be done with field info? -> Field queries!
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Field queries

                | Term | Doc IDs |
                |-------------|-------------------------------|
                | arthur | #1:Author, #2:Title |
                | shakesbeer | #2:Author |
                | ... |

                ***

                * <!-- .element: class="fragment" --> `title:arthur`?
                    * <!-- .element: class="fragment" --> #2
                * <!-- .element: class="fragment" --> `author:shakesbeer`?
                    * <!-- .element: class="fragment" --> #2

                Notes:
                * Audience question
                </script>
            </section>
        </section>

        <section id="vector_space_model_section">
            <section id="vector_space_model" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector Space Model

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector Space Model

                    Calculate similarity between

                    * queries and docs <!-- .element: class="fragment" -->
                    * docs and docs <!-- .element: class="fragment" -->
                    * queries and queries <!-- .element: class="fragment" -->

                    Notes:
                    * Use case for doc-doc?
                    * Use case for query-query?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector Space Model

                    * Queries / docs are vectors <!-- .element: class="fragment" -->
                    * Term-document Matrix &rarr; document vector <!-- .element: class="fragment" -->

                    Notes:
                    How can a document be a vector?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document vector

                    |             | #1 | #2 | #3 |
                    |-------------|----|----|----|
                    | Book        | 10 | 3  |  0 |
                    | Information | 5  | 2  |  1 |

                    ***

                    * $\vec{V}(\\#1)$ = (10, 5) <!-- .element: class="fragment" -->
                    * $\vec{V}(\\#2)$ = (3, 2) <!-- .element: class="fragment" -->
                    * $\vec{V}(\\#3)$ = (0, 1) <!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * $\vec{V}(\\#1)$ = (10, 5)
                    * $\vec{V}(\\#2)$ = (3, 2)

                    <p class="stretch">![Vectors](images/Vectors.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes: Audience question: Are the docs similar?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector distance

                    <p class="stretch">![Vector distance](images/Vector Distance.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector distance

                    $$\textrm{d}(p, q) = \sqrt{(q_1 - p_1)^2 + (q_2 - p_2)^2}$$

                    Notes:
                </script>
            </section>

            <section>
                <h1>Vector distance</h1>

                \[\begin{aligned}
                \textrm{d}(\#1, \#2) & = \sqrt{(10 - 3)^2 + (5 - 2)^2} \\
                & = \sqrt{7^2 + 3^2} \\
                & = \sqrt{49 + 9} \\
                & = \sqrt{58} \\
                & \approx 7.62
                \end{aligned} \]

                <aside class="notes">

                </aside>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * Documents look similar but vector distance is pretty big
                    * <!-- .element: class="fragment" --> Vector distance does not consider document size
                    * <!-- .element: class="fragment" --> Need a better measure that accounts for longer documents
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    * $\vec{V}(\\#1)$ = (10, 5)
                    * $\vec{V}(\\#2)$ = (3, 2)

                    <p class="stretch">![Vectors](images/Vectors.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![Vector Similarity](images/Vector Similarity.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section>
                <h1>Unit vector</h1>

                $$\vec{v} = \frac{\vec{V} }{ |\vec{V}| }$$

                <aside class="notes">

                </aside>
            </section>

            <section>
                <h1>Unit vector</h1>

                \[\begin{aligned}
                \vec{v}(\#1) & = \frac{ \begin{pmatrix}10\\5\end{pmatrix} }{ \sqrt{10^2 + 5^2} } \\ \\
                & = \frac{ \begin{pmatrix}10\\5\end{pmatrix} }{ 11.18 } \\ \\
                & = \begin{pmatrix}0.89\\0.45\end{pmatrix}
                \end{aligned} \]

                <aside class="notes">

                </aside>
            </section>

            <section>
                <h1>Unit vector</h1>

                \[\begin{aligned}
                |\vec{v}(\#1)| & = \sqrt{0.89^2 + 0.45^2} \\
                & = \sqrt{1} \\
                & = 1
                \end{aligned}\]

            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Cosine similarity

                    $$\textrm{sim}(d_1, d_2) = \frac{ \vec{V}(d_1) }{ |\vec{V}(d_1)|} \cdot \frac{\vec{V}(d_2) }{ |\vec{V}(d_2)| } =
                    \frac{ \vec{V}(d_1) \vec{V}(d_2) }{ |\vec{V}(d_1)| |\vec{V}(d_2)| }$$

                    ****

                    * 1.0 means equality (same vector direction)
                    * 0.0 means maximum difference (90° between vectors)

                    Notes: Why can't there be more than 90° difference?
                </script>
            </section>

            <section>
                <h1>Cosine similarity</h1>

                \[\begin{aligned}
                \textrm{sim}(d_1, d_2) & = \frac{ \begin{pmatrix}10 \\ 5\end{pmatrix} \cdot \begin{pmatrix}3 \\
                2\end{pmatrix} }{ \left|\begin{pmatrix}10 \\ 5\end{pmatrix}\right| \left|\begin{pmatrix}3 \\
                2\end{pmatrix}\right| } \\ \\
                & = \frac{30 + 10}{\sqrt{10^2 + 5^2} \sqrt{3^2 + 2^2}} \\
                & = \frac{40}{\sqrt{125} \sqrt{13}} = \frac{40}{40.31} \\
                & \approx 0.99
                \end{aligned}\]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query vector

                    * "*book*"
                    * $\vec{V}(q) = \begin{pmatrix}1 \\\\ 0\end{pmatrix}$ <!-- .element: class="fragment" -->

                    Notes:
                    What does the query vector look like?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![Vectors](images/Vectors.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                    What does the query vector look like?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query vector

                    <p class="stretch">![Query](images/Query Vector.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes: Audience question: Which doc is a better match?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query vector

                    $$sim(\\#1, q) = \frac{ \begin{pmatrix}10 \\\\ 5\end{pmatrix} \cdot \begin{pmatrix}1 \\\\ 0\end{pmatrix} }{ \left\|\begin{pmatrix}10 \\\\ 5\end{pmatrix}\right\| \left\|\begin{pmatrix}1 \\\\ 0\end{pmatrix}\right\| } = 0.89$$ <!-- .element: class="fragment" -->

                    $$sim(\\#2, q) = \frac{ \begin{pmatrix}3 \\\\ 2\end{pmatrix} \cdot \begin{pmatrix}1 \\\\ 0\end{pmatrix} }{ \left\|\begin{pmatrix}3 \\\\ 2\end{pmatrix}\right\| \left\|\begin{pmatrix}1 \\\\ 0\end{pmatrix}\right\| } = 0.83$$ <!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>

        </section>

        <section id="scaling_section">
            <section id="scaling" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling

                    Notes:

                    Scaling reasons?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling reasons

                    * Query volume <!-- .element: class="fragment" -->
                    * Index volume <!-- .element: class="fragment" -->
                    * Resiliency <!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling

                    ![scaling](images/scaling.png) <!-- .element: style="border: none; box-shadow: none;" -->

                    Notes:
                    What are the two directions we can scale to?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling up / Vertical

                    ![scaling up](images/scaling up.png) <!-- .element: style="border: none; box-shadow: none;" -->

                    Notes:

                    (Dis-)Advantages of Scaling up?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling up

                    * \+ Easy
                    * \+ Little overhead (network, hardware)
                    * \- No fault-tolerance
                    * \- No parallelization
                    * \- Scaling limited by hardware

                    <!-- .element: style="list-style-type: none;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling out / Horizontal

                    ![scaling out](images/scaling out.png) <!-- .element: style="border: none; box-shadow: none;" -->

                    Notes:

                    (Dis-)Advantages of Scaling out?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Scaling out

                    * \+ Fault-tolerance, resiliency
                    * \+ Parallelization
                    * \+ "Unlimited" scaling
                    * \- Complex
                    * \- Overhead: Network, Monitoring

                    <!-- .element: style="list-style-type: none;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed search

                    ![Distributed Search](images/Distributed Search.png) <!-- .element: style="border: none; box-shadow: none;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed search

                    * Partitioned index
                    * Distributed queries

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Non-Partitioned index


                    | Term        | Doc IDs    |
                    |-------------|------------|
                    | Book        | #1, #2, #3 |
                    | Information | #1, #2, #3 |
                    | Retrieval   | #1         |
                    | Search      | #2         |


                    Notes: Audience question: How to partition?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Partitioned index

                    * By term
                    * By doc

                    Notes:
                    How can the index be partitioned? Think of the Inverted Index.
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Term-partitioned index

                    <p class="stretch">![Term-partitioned index](images/Term-partitioned index.png)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:

                    (Dis-)Advantages of Term-partitioned index?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Term-partitioned index

                    * \+ Single term queries are easy
                    * \- Uneven distribution
                    * \- Heavy inter-node communication
                    * \- Hard to update index

                    <!-- .element: style="list-style-type: none;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document-partitioned index

                    <p class="stretch">![Document-partitioned index](images/Document-partitioned index.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                    Notes:

                    (Dis-)Advantages of Term-partitioned index?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document-partitioned index

                    * \+ Even distribution
                    * \+ Little inter-node communication
                    * \+ Easy to update index
                    * \+ Completely independent partial indices
                    * \- Even single query terms are complex

                    <!-- .element: style="list-style-type: none;" -->

                    Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document-partitioned index

                    * Number of nodes is fixed
                    * $\text{node}(\text{doc}) = \text{id}(\text{doc}) \, \% \, \text{num}(\text{nodes})$
                    * $\text{node}(\text{#4}) = 4 \, \% \, 3 = 1$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed query

                    <p class="stretch">![Document-partitioned query](images/Document-partitioned query.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>


                    Notes:

                    What is the performance improvement?
                </script>
            </section>

            <section data-markdown>
                <textarea data-template>
                    # Performance improvement

                    $$\text{Distributed query time} \approx \frac{\text{Non-distributed query time}}{\text{Number of nodes}}$$<!--
                    .element: class="fragment" -->

                </textarea>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <textarea data-template>
                    # Further improvements

                    * Handle more traffic
                    * Handle failure

                    Notes:
                    How?
                </textarea>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Sharding

                    <p class="stretch">![sharding](images/Sharding.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p><!-- .element: class="fragment" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Sharding nomenclature

                    ## Shard <!-- .element: class="fragment" data-fragment-index="1" -->

                    * Slice of document collection <!-- .element: class="fragment" data-fragment-index="1" -->

                    ## Master / Leader / Primary <!-- .element: class="fragment" data-fragment-index="2" -->

                    * Distribute requests to Replicas <!-- .element: class="fragment" data-fragment-index="2" -->
                    * Distribute requests to other Masters <!-- .element: class="fragment" data-fragment-index="2" -->

                    ## Replica <!-- .element: class="fragment" data-fragment-index="3" -->

                    * Contains all documents of shard <!-- .element: class="fragment" data-fragment-index="3" -->
                    * Will actually handle queries <!-- .element: class="fragment" data-fragment-index="3" -->
                    * Can become Master <!-- .element: class="fragment" data-fragment-index="3" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # More shards

                    * More docs
                    * Better query parallelization
                        * A single query is faster
                        * $\text{Shards} \times 2 \approx \text{Index} \div 2 \approx \text{Performance} \times 2$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # More Replicas

                    * Better resiliency
                    * Better concurrency
                        * More queries can be handled in parallel
                        * $\text{Replicas} \times 2 \approx \text{Parallel queries} \times 2$

                    Notes:
                </script>
            </section>

        </section>

        <section id="web_search_usage_section">
            <section id="web_search_usage" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web search usage

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # User intents

                    Change search result page depending on intent

                    * Informational: Find information <!-- .element: class="fragment" data-fragment-index="" -->
                    * Navigational: Find homepage <!-- .element: class="fragment" data-fragment-index="" -->
                    * Transactional: Find product <!-- .element: class="fragment" data-fragment-index="" -->
                    * Local: Find place <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Informational queries

                    ## Know

                    Majority of search traffic

                    * "computer science" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "salzburg sights" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "lolcats" <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Examples?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Informational queries

                    ## Know simple

                    Clear facts

                    * "how old is sebastian kurz" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "5 usd in eur" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "capitol of austria" <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Examples?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![know simple currency](images/know simple currency.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![know simple vienna](images/know simple vienna.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Navigational queries

                    ## Go

                    * "fh salzburg homepage" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "youtube" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "apple.com" <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Examples?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Transactional queries

                    ## Do

                    * "buy iphone 7" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "flight to salzburg" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "viagra" <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Examples?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![transactional iphone](images/transactional iphone.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![transactional flight](images/transactional flight.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![transactional sign up](images/transactional sign up.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Local queries

                    ## Visit-in-person

                    * "pizza place" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "bike repair" <!-- .element: class="fragment" data-fragment-index="" -->
                    * "fh salzburg" <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Examples?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![local pizza](images/local pizza.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![local bike repair](images/local bike repair.png)

                Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Interpretation

                    * Often subjective
                    * "iphone"<!-- .element: class="fragment" data-fragment-index="" -->
                        * Informational or transactional?<!-- .element: class="fragment" data-fragment-index="" -->
                    * "libro"<!-- .element: class="fragment" data-fragment-index="" -->
                        * Navigational or visit-in-person?<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                ![intent libro](images/intent libro.png)

                Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # But wait, there's more

                    [Google Search Quality Evaluator Guidelines](https://www.google.com/insidesearch/howsearchworks/assets/searchqualityevaluatorguidelines.pdf)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web search users

                    * Not professionals
                    * Do not know whole internet
                    * Do not know query syntax
                    * Want quick results

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query syntax

                    * 2-3 query terms
                    * No boolean operators
                    * No wildcards
                    * Maybe phrases

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Conclusion

                    * Don't require query syntax
                    * High precision on first result page
                    * Keep result page lightweight

                    Notes:
                </script>
            </section>
        </section>

        <section id="web_search_challenges_section">
            <section id="web_search_challenges" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web search challenges

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Technical challenges

                    * Huge amount of data <!-- .element: class="fragment" data-fragment-index="" -->
                    * Frequent updates <!-- .element: class="fragment" data-fragment-index="" -->
                    * Unstructured content <!-- .element: class="fragment" data-fragment-index="" -->
                    * Un-indexable content (images, flash) <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Page quality

                    * <!-- .element: class="fragment" data-fragment-index="1" --> **E**xpertise
                    * <!-- .element: class="fragment" data-fragment-index="2" --> **A**uthoritativeness
                    * <!-- .element: class="fragment" data-fragment-index="3" --> **T**rustworthiness

                    Notes:
                    * Come up with examples of websites that rank high on one of those scales.
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Page quality

                    * Spam <!-- .element: class="fragment" data-fragment-index="1" -->
                    * Duplicate content <!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    * Come up with examples. How could you detect this?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Quality challenges

                    ## Result quality

                    * User intent <!-- .element: class="fragment" data-fragment-index="" -->
                    * Misspellings <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                </script>
            </section>
        </section>

        <section id="internet_structure_section">
            <section id="internet_structure" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet Structure
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![web graph](images/web graph.png)

                    * Directed graph connected by hyperlinks
                    * Not strongly connected

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## In-links / Out-links

                    Incoming / Outgoing links

                    ## In-degree / Out-degree

                    Number of incoming / outgoing links

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![web graph](images/web graph.png)

                    * B
                    * In-degree: *3* <!-- .element: class="fragment" data-fragment-index="" -->
                    * Out-degree: *1* <!-- .element: class="fragment" data-fragment-index="" -->

                    Notes: Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    Number of web pages with in-degree *i* =

                    $$\frac{1}{i^{2.1}}$$

                    Notes:
                </script>
            </section>

            <section>
                <div class="plot stretch" id="myplot2">
                    <!--
                     {
                      "width": "800",
                      "height": "600",
                      "xAxis": {
                       "domain": ["0", "20"],
                       "label": "In-degree"
                      },
                      "yAxis": {
                       "domain": ["0", "10000"],
                       "label": "Proportional number of pages"
                      },
                      "data": [{ "fn": "10000*1/nthRoot(x, 2.1)" }]
                    }
                    -->
                </div>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Internet structure

                    ![bowtie](images/bowtie.png)<!-- .element: class="stretch" -->

                    Notes:
                </script>
            </section>
        </section>

        <section id="web_crawling_section">
            <section id="web_crawling" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawling

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawler requirements

                    ### Robustness <!-- .element: class="fragment" data-fragment-index="1" -->

                    Handle malicious and faulty pages <!-- .element: class="fragment" data-fragment-index="1" -->

                    ### Politeness <!-- .element: class="fragment" data-fragment-index="2" -->

                    Rate limit <!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web crawler requirements

                    ### Distributed <!-- .element: class="fragment" data-fragment-index="1" -->

                    Scalable, efficient <!-- .element: class="fragment" data-fragment-index="1" -->

                    ### Quality <!-- .element: class="fragment" data-fragment-index="2" -->

                    Crawl "good" pages more frequently <!-- .element: class="fragment" data-fragment-index="2" -->

                    ### Freshness <!-- .element: class="fragment" data-fragment-index="3" -->

                    Keep index up-to-date <!-- .element: class="fragment" data-fragment-index="3" -->

                    ### Extensible <!-- .element: class="fragment" data-fragment-index="4" -->

                    Data formats, protocols <!-- .element: class="fragment" data-fragment-index="4" -->

                    Notes:
                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Crawling

                    ![Web crawler architecture](images/WebCrawlerArchitecture.svg)<!-- .element: style="padding: 25px;" class="stretch" -->

                    [Source](https://de.wikipedia.org/wiki/Datei:WebCrawlerArchitecture.svg)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # URL Queue

                    * aka. *Crawl frontier*
                    * Priority queue

                    `priority = f(quality, importance, change rate)`

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed Crawling

                    * Partition by domain
                    * Cache DNS
                    * Locality

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Distributed indexes

                    * <!-- .element: class="fragment" --> Document-partitioned
                    * <!-- .element: class="fragment" --> Partition by Host or URL?
                    * <!-- .element: class="fragment" --> `hash(URL)` is more uniform

                    Notes:

                    * `hash(URL)` or `host`?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link graph

                    ![web graph](images/web graph.png)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link graph

                    * Connectivity servers / indices
                    * Store web graph, in- and out-links
                    * Support graph queries: in- / out-links, in- / out-degree, traversal
                    * Used for link analysis etc.

                    Notes:
                </script>
            </section>
        </section>

        <section id="google_section">
            <section id="google" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What would Google do?

                    [Web search for a planet: the google cluster architecture (2003)](https://static.googleusercontent.com/media/research.google.com/de//archive/googlecluster-ieee.pdf)

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic assumptions

                    * Search can be parallelized
                    * High-end hardware fails too
                    * Throughput > performance

                    &darr;

                    * Rely on software, not hardware
                    * Use commodity hardware
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Parallelize

                    * Focus on parallel queries
                    * Achieve high throughput
                    * Parallelize at CPU or Cluster level
                    * 10s query parallelized on 10 nodes takes 1s

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query time

                    ![Google cluster](images/google-cluster.png)
                    [Source](https://static.googleusercontent.com/media/research.google.com/de//archive/googlecluster-ieee.pdf) <!-- .element: style="font-size: smaller;" -->

                    * Index servers: Inverted Index, document-partitioned
                    * Document servers: Copy of entire internet
                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Query time

                    1. Query index servers &rarr; doc IDs
                    2. Intersect doc IDs &rarr; result set
                    3. Fetch doc IDs from doc servers &rarr; (Title, URL, result snippet)
                    4. Generate search result page

                    Notes:
                </script>
            </section>
        </section>

        <section id="web_spam_section">
            <section id="web_spam" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Web spam

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Types of web spam

                    * Keyword spam (exploits TF metric)<!-- .element: class="fragment" data-fragment-index="" -->
                    * Cloaking (show different page for human / crawler)<!-- .element: class="fragment" data-fragment-index="" -->
                    * Meta tags<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:

                    Audience question
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Counter web spam

                    * Link analysis

                    Notes:
                </script>
            </section>
        </section>

        <section id="link_analysis_section">
            <section id="link_analysis" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link analysis

                    Notes:
                    How to use link analysis to determine relevant pages?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Assumption

                    ![web graph](images/web graph.png)

                    * In-link = endorsement
                    * Similar to citation analysis

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Link info

                    * Anchor text describes target page
                        * "[computer manufacturer](http://lenovo.com)" &rarr; lenovo.com
                    * Also text surrounding links
                        * "Find funny cat pics [here](http://icanhascheezburger.com)"
                    * May also be abused
                        * "[evil empire](http://www.korea-dpr.com/)"

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # PageRank

                    * Rank pages with many in-links higher
                    * PageRank =~ In-degree
                    * Probability that random surfer will end up on page
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Pagerank calculation

                    1. Assume random surfer
                    2. Randomly walk web graph
                    * No out-links &rarr; teleport
                    * 15% chance that user opens random page
                    3. Count how many times page is visited

                    $$\sum \text{pagerank} = 1$$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    [Pagerank visualization](http://bl.ocks.org/emeeks/raw/f448eef177b5fe94b1c0/)

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Reasonable surfer

                    * Clicks some links more often than others
                    * Main content vs sidebar / footer
                    * Anchor text related to query / user intent
                    * Ads

                    Notes:
                </script>
            </section>
        </section>

        <section id="classification_section">
            <section id="classification" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Text Classification

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What?

                    * Assign document to class(es)
                    * Based on document features:
                        * Contents
                        * Age
                        * Popularity
                        * …

                    Notes:

                    * What are use cases?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Standing queries (Google Alerts)
                    * Spam filter
                    * Webspam detection
                    * Language detection
                    * Sentiment detection

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    * Make humans do it<!-- .element: class="fragment" data-fragment-index="1" -->
                        * Needs domain experts<!-- .element: class="fragment" data-fragment-index="1" -->
                        * Does not scale with amount of data<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Make machines do it<!-- .element: class="fragment" data-fragment-index="2" -->
                        * Needs lots of data<!-- .element: class="fragment" data-fragment-index="2" -->

                    Notes:
                    * How?
                    * What's the issue with humans doing it?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Supervised learning

                    <p class="stretch">![Supervised Learning](images/Supervised Learning.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Supervised Learning Example

                    ![Man Woman Classifier](images/Man Woman Classifier.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Nomenclature

                    ## Learning Method

                    Computes classifier

                    ## Classifier

                    Determines class of document

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Class membership

                    * Single / one-of
                        * Spam<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Multiple / any-of
                        * Language<!-- .element: class="fragment" data-fragment-index="2" -->

                    # Classifiers

                    * One class: Belongs to class or not
                        * Spam<!-- .element: class="fragment" data-fragment-index="3" -->
                    * Two class: Belongs to one of two classes
                        * Positive or negative sentiment<!-- .element: class="fragment" data-fragment-index="4" -->
                    * Multi class: Belongs to one of many classes
                        * Language<!-- .element: class="fragment" data-fragment-index="5" -->

                    Notes:
                    Examples?
                </script>
            </section>
        </section>

        <section id="naive_bayes_section">
            <section data-markdown>
                <textarea data-template>
                    # Naive Bayes Classficiation
                </textarea>
            </section>
            <section id="naive_bayes" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability

                    Probability of A if B:

                    $$P(A | B)$$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability Examples

                    Probability that it will snow in winter:<!-- .element: class="fragment" -->

                    $$P(\text{snow} | \text{winter}) = \frac{\text{Days with snow in winter}}{\text{Days in winter}} = \frac{15}{90} =
                    16\%$$<!-- .element: class="fragment" -->

                    Probability that it will snow in summer:<!-- .element: class="fragment" -->

                    $$P(\text{snow} | \text{summer}) = \frac{\text{Days with snow in summer}}{\text{Days in summer}} = \frac{0}{90} =
                    0\%$$<!-- .element: class="fragment" -->

                    Probability that it's winter if it snows:<!-- .element: class="fragment" -->

                    $$P(\text{winter} | \text{snow}) = \frac{\text{Days with snow in winter}}{\text{Days with snow all year}} =
                    \frac{15}{17} =
                    88\%$$<!-- .element: class="fragment" -->

                    Notes:
                    Audience questions
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Basic Probability Examples

                    Probability that it will snow:<!-- .element: class="fragment" -->

                    $$P(\text{snow}) = \frac{\text{Days with snow per year}}{\text{Days in the year}} = \frac{17}{365} =
                    5\%$$<!-- .element: class="fragment" -->

                    Probability of winter:<!-- .element: class="fragment" -->

                    $$P(\text{winter}) = \frac{\text{Days in winter per year}}{\text{Days in the year}} = \frac{90}{365} =
                    25\%$$<!-- .element: class="fragment" -->

                    Notes:
                    Audience questions
                </script>
            </section>

            <section>
                <h1>Bayes Theorem</h1>

                \[\begin{aligned}
                P(A | B) &= \frac{P(A) \times P(B | A)}{P(B)}\\
                \\
                P(\text{winter} | \text{snow}) &= \frac{P(\text{winter}) \times P(\text{snow} | \text{winter})}{P(\text{snow})}\\
                \\
                &= \frac{0.25 \times 0.16}{0.05} = 0.8\\
                \\
                &\approx \frac{\text{Days with snow in winter}}{\text{Days with snow all year}} = \frac{15}{17} = 0.88
                \end{aligned}\]
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <textarea data-template>
                    # Bayes for text classification

                    Probability that document belongs to class:<!-- .element: class="fragment" data-fragment-index="1" -->

                    $$P(\text{class} | \text{document})$$<!-- .element: class="fragment" data-fragment-index="1" -->

                    Probability that mail with $\text{\$content}$ is spam:<!-- .element: class="fragment" data-fragment-index="2" -->

                    $$P(\text{spam} | \text{\$content})$$<!-- .element: class="fragment" data-fragment-index="2" -->

                    This probability is not known.<!-- .element: class="fragment" data-fragment-index="4" -->
                </textarea>
            </section>

            <section>
                <h1>Bayes Theorem</h1>

                \[\begin{aligned}
                P(\text{spam} | \text{\$content}) &= \text{Probability that mail with $\text{\$content}$ is spam}\\
                &= \frac{P(\text{spam}) \times P(\text{\$content} | \text{spam})}{P(\text{\$content})}\\
                \end{aligned}\]
                <aside class="notes">
                    How to calculate these probabilities?
                </aside>
            </section>

            <section>
                <h1>Known:</h1>

                <p>Based on training data.</p>

                \[\begin{aligned}
                P(\text{spam}) &= \frac{\text{Number of spam mails}}{\text{Total number of mails}}\\
                \\
                P(\text{\$content} | \text{spam}) &= \prod_{\$term \in \$content} P(\text{\$term} | \text{spam})\\
                &= P(\text{\$term1} | \text{spam}) \times P(\text{\$term2} | \text{spam}) \times …\\
                \\
                P(\text{\$term} | \text{spam}) &= \frac{\text{Document frequency of \$term in Spam} + 1}{\text{Unique words in Spam} + \text{Total unique words}}
                \end{aligned}\]
            </section>

            <section>
                \[\begin{aligned}
                P(\text{spam} | \text{\$content}) &= \frac{P(\text{spam}) \times P(\text{\$content} | \text{spam})}{P(\text{\$content})}\\
                \\
                P(\text{ham} | \text{\$content}) &= \frac{P(\text{ham}) \times P(\text{\$content} | \text{ham})}{P(\text{\$content})}\\
                \end{aligned}\]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    If $P(\text{spam} | \text{\$content}) > P(\text{ham} | \text{\$content})$ then mail is spam, so:

                    $$\text{Spam:} \frac{P(\text{spam} | \text{\$content})}{P(\text{ham} | \text{\$content})} = \frac{P(\text{spam}) \times
                    P(\text{\$content} | \text{spam})}{P(\text{ham}) \times P(\text{\$content} | \text{ham})} > 1$$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <textarea data-template>
                    # Naive Bayes

                    * Naive = Assumes features are independent
                        * Features: ("rolex", "replica") are not independent
                    * Predicts probability for class, not class
                    * Robust to concept drift ("viagra" &rarr; "cialis")
                    * Robust to noise ("unusual" documents)
                    * Efficient and effective

                    Notes:

                    * Example for dependent features?
                </textarea>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Example

                    https://docs.google.com/spreadsheets/d/1Cim4llHxSKF-meYq8qZEZmVU8OUPMDiBvFj4WCNPv34/edit?usp=sharing

                    Notes:
                </script>
            </section>
        </section>

        <section id="feature_selection_section">
            <section id="feature_selection"data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Feature Selection

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Do not use all terms for training
                    * Less terms = better training and runtime performance
                    * Reduce noise

                    Notes:
                    Ideas?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Text analysis

                    * Stopwords
                    * Stemming
                    * N-Grams, word sequences

                    Notes:
                </script>
            </section>
        </section>

        <section id="vector_space_classification_section">
            <section id="vector_space_classification" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Vector Space Classification
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Document as vector

                    <p class="stretch">![Vectors](images/Vectors.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![Vector Space Classification](images/Vector Space Classification.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Rocchio Classification

                    Supports multiple classes

                    1. Compute center of mass / centroid for class
                    2. Assign documents to class of nearest centroid
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Rocchio Classification

                    <p class="stretch">![Rocchio](images/Rocchio.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:

                    What is the class of the new document?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # k Nearest Neighbor (kNN)

                    Supports multiple classes

                    * Assign document to class of the majority of the k nearest neighors
                    * $k = 1$: Closest neighbor
                    * Usually $k = 3$ or $k = 5$
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # k Nearest Neighbor (kNN)

                    <p class="stretch">![kNN](images/kNN.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:

                    What's the class?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Support Vector Machines (SVM)

                    Supports exactly two classes

                    * Separate documents into two classes
                    * By drawing a _line_ between the two classes

                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Which _line_?

                    <p class="stretch">![SVM Possibilities](images/SVM Possibilities.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:

                    Audience question. Which line and why?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Hyperplane

                    * 1 dimensional: point
                    * 2 dimensional: line
                    * 3 dimensional: plane

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Which hyperplane?

                    Choose hyperplane with largest margin:

                    Larger margin

                    &darr;

                    More wiggle room for both classes

                    &darr;

                    More confident decision

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Hyperplane with largest margin

                    <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # SVM Outliers

                    <p class="stretch">![SVM Outliers](images/SVM Outliers Problem.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Outliers decrease margin

                    <p class="stretch">![SVM Outliers](images/SVM Outliers.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # SVM Outliers

                    * Outliers could be noise
                    * Ignore for greater margin
                    * Pay penalty for each outlier

                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # SVM Outliers

                    <p class="stretch">![SVM Outliers](images/SVM Outliers Solved.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Linearly inseparable data

                    <p class="stretch">![SVM not separable](images/SVM not separable.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # SVM Kernel Trick

                    Transform to higher dimension

                    <p class="stretch">![SVM Kernel Trick](images/SVM Kernel Trick.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Which classifier to use?

                    * Is the problem linear?
                    * Can a hyperplane separate the classes?

                    <p class="stretch">![Linear Non-Linear](images/Linear Non-Linear.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Classifier types

                    * Linear classifier: Separates classes with hyperplane
                    * Non-Linear classifier: Opposite
                    * Linear classifier is more robust
                    * But cannot solve non-linear problems

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Is classifier linear?

                    1. Classify new document
                    2. Do this many times
                    3. Is border between classes a hyperplane?
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Rocchio Classification: Linear?

                    <p class="stretch">![Rocchio](images/Rocchio.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Rocchio Classification: Linear

                    <p class="stretch">![Rocchio Linear](images/Rocchio Linear.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # kNN: Linear?

                    <p class="stretch">![kNN](images/kNN.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # kNN: Non-Linear

                    <p class="stretch">![kNN Non-Linear](images/kNN Non-Linear.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # SVM

                    <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Linear? *Yes*<!-- .element: class="fragment" data-fragment-index="" -->
                    Notes:

                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Overfitting

                    ![Overfitting](images/Man Woman Classifier Overfitting.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Underfitting

                    ![Underfitting](images/Man Woman Classifier Underfitting.svg)<!-- .element: class="stretch" style="border: none; box-shadow: none; vertical-align: middle;" -->

                    Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Bias-Variance trade-off

                    How does classifier change per training set?

                    * High bias:
                        * Consistent, but inaccurate
                        * Underfitting, cannot learn true signal
                    * High variance:
                        * Accurate, but inconsistent
                        * Overfitting, memorize noise
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![Rocchio Linear](images/Rocchio Linear.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    * Bias: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                    * Variance: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![kNN Non-Linear](images/kNN Non-Linear.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    * Bias: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                    * Variance: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![SVM Solution](images/SVM Solution.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    * Bias: *high*<!-- .element: class="fragment" data-fragment-index="" -->
                    * Variance: *low*<!-- .element: class="fragment" data-fragment-index="" -->
                </script>
            </section>
        </section>

        <section id="clustering_section">
            <section id="clustering" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Clustering

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # What?

                    * Classes are not known
                    * Assign similar documents to same class / cluster

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Show similar documents<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Cluster search results<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Exploratory browsing<!-- .element: class="fragment" data-fragment-index="1" -->
                    * News aggregation<!-- .element: class="fragment" data-fragment-index="1" -->

                    Notes:
                    Why?
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    * Unsupervised learning
                    * No labeled documents available

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Types of clustering

                    * *Hard*: Document belongs to exactly one cluster
                    * *Soft*: Document can belong to multiple clusters with varying degrees
                    * *Flat*: One level of clusters
                    * *Hierarchical*: Sub-clusters

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # K-Means

                    1. Set $K$ random centroids
                    2. Assign each document to nearest centroid
                    3. Move centroids to minimize distance to documents
                    4. Terminate or goto 2


                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    <p class="stretch">![K-Means](images/K-Means.png)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    <span style="font-size: x-small">© 2008 Cambridge University Press</span>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Termination

                    * Centroids do not move<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Assignment do not change<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Sum of distances does not decrease<!-- .element: class="fragment" data-fragment-index="1" -->
                    * Sum of distances is below threshold<!-- .element: class="fragment" data-fragment-index="1" -->
                    * After $n$ iterations<!-- .element: class="fragment" data-fragment-index="1" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # K-Means disadvantages

                    * Can get stuck on local minimum
                    * Can build singleton clusters for outliers
                    * Can build empty clusters

                    Notes:
                </script>
            </section>
        </section>

        <section id="machine_learning_section">
            <section id="machine_learning" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Machine Learning for Ranked Retrieval

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Why?

                    * Getting field weights right is hard
                    * Title match > Meta keyword match?
                    * Query "iphone": "iPhone cover" > "iPhone X"?

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # How?

                    1. Calculate weights
                    2. Apply new weights
                    3. Compare actual rank to expected rank (nDCG, MAP, ERR, …)
                    4. Try harder

                    Notes:
                </script>
            </section>
        </section>

        <section id="ltr_section">

            <section id="ltr" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                # Calculate Weights
                </script>
            </section>

            <section id="calculate_weights" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Obtain result clicks

                    | Query  | Document<!-- .element: class="fragment" data-fragment-index="1" -->     | Frequency<!-- .element: class="fragment" data-fragment-index="2" --> | Rank<!-- .element: class="fragment" data-fragment-index="3" --> |
                    |--------|--------------|-----------|------|
                    | iphone | iPhone 8<!-- .element: class="fragment" data-fragment-index="1" -->     | 5<!-- .element: class="fragment" data-fragment-index="2" -->         | 2<!-- .element: class="fragment" data-fragment-index="3" -->    |
                    | iphone | iPhone X<!-- .element: class="fragment" data-fragment-index="1" -->     | 11<!-- .element: class="fragment" data-fragment-index="2" -->        | 3<!-- .element: class="fragment" data-fragment-index="3" -->    |
                    | iphone | iPhone cover<!-- .element: class="fragment" data-fragment-index="1" --> | 2<!-- .element: class="fragment" data-fragment-index="2" -->         | 1<!-- .element: class="fragment" data-fragment-index="3" -->    |

                    Optimal order:<!-- .element: class="fragment" data-fragment-index="5" -->

                    1. iPhone X<!-- .element: class="fragment" data-fragment-index="5" -->
                    2. iPhone 8<!-- .element: class="fragment" data-fragment-index="5" -->
                    3. iPhone cover<!-- .element: class="fragment" data-fragment-index="5" -->

                    Or use manual relevance judgement<!-- .element: class="fragment" data-fragment-index="6" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # From

                    <p class="stretch">![Regular Search pipeline](images/Search pipeline.jpg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # To

                    <p class="stretch">![LTR Search pipeline](images/LTR Search pipeline.jpg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    Notes:
                </script>
            </section>

            <section>
                <h1>Calculate weights</h1>

                <p>$$f(\text{query}, \text{document / features}, \text{feature weights}) = \text{rank}$$</p>

                <div class="fragment">
                    <h3>Solve for <em>weights</em>:</h3>

                    \[\begin{aligned}
                    &f(\text{iphone}, \text{iPhone 8}, \text{weights}) &= 2\\
                    &f(\text{iphone}, \text{iPhone X}, \text{weights}) &= 3\\
                    &f(\text{iphone}, \text{iPhone cover}, \text{weights}) &= 1\\
                    \end{aligned}\]
                </div>

                <aside class="notes">

                </aside>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Machine Learning

                    * RankSVM
                    * PRanking
                    * LambdaMART
                    * GBRT
                    * …

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Features

                    * Keyword / field relevance, using TF-IDF<!-- .element: class="fragment" data-fragment-index="" -->
                        * Query: *iphone*, title: *iPhone X* &rarr; 1
                        * Query: *iphone*, title: *Samsung Galaxy* &rarr; 0
                    * Other attributes<!-- .element: class="fragment" data-fragment-index="" -->
                        * Product age
                        * Number of sales
                        * …

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Defining features

                    * Requires human effort
                    * Less is more

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Feature Store

                    ```json
                    [{
                        "name":"documentRecency",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!func}recip( ms(NOW,last_updated_dt), 3.16e-11, 1, 1)"},
                        "store":"wikipedia"
                    }, {
                        "name":"popularity",
                        "class":"org.apache.solr.ltr.feature.FieldValueFeature",
                        "params":{"field":"popularity_score_d"},
                        "store":"wikipedia"
                    }, {
                        "name":"totalScore",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!edismax qf=\"title_txt_en headings_txt_en categories_txts_en opening_text_txt_en text_txt_en\"}${text}"},
                        "store":"wikipedia"
                    }, {
                        "name":"titleScore",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!edismax qf=\"title_txt_en\"}${text}"},
                        "store":"wikipedia"
                    }, {
                        "name":"exactTitle",
                        "class":"org.apache.solr.ltr.feature.SolrFeature",
                        "params":{"q":"{!df=\"title_exact_s_lower\"}${text}"},
                        "store":"wikipedia"
                    }]
                    ```

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Feature Extraction

                    Query: *iphone x*

                    ```json
                    [{
                        "title_txt_en": "IPhone X",
                        "[features]": "documentRecency:0.94301736 popularity:1.2207552E-5 totalScore:22.804134 titleScore:17.452236 exactTitle:11.403795 headingsScore:0.0 categoriesScore:0.0 openingScore:22.804134 textScore:19.482597"
                    },
                    {
                        "title_txt_en": "OS X Mountain Lion",
                        "[features]": "documentRecency:0.59085584 popularity:3.140487E-6 totalScore:19.74273 titleScore:5.4706 exactTitle:0.0 headingsScore:0.0 categoriesScore:8.784399 openingScore:8.180487 textScore:17.705677"
                    },
                    {
                        "title_txt_en": "IPhone",
                        "[features]": "documentRecency:0.97925586 popularity:6.251065E-5 totalScore:16.994913 titleScore:12.235063 exactTitle:0.0 headingsScore:0.0 categoriesScore:0.0 openingScore:15.402786 textScore:15.681499"
                    }]
                    ```

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    | Rank | Query | Title relevance | Age | FeatureN | Comment        |
                    |------|----------|-----------------|-----------------|-----------------|----------------|
                    | 2    | *iphone*    | 0.2             | 0.3             | 1             | # iPhone 8     |
                    | 3    | *iphone*    | 1.3             | 0.9             | 0             | # iPhone X     |
                    | 1    | *iphone*    | 0.1             | 1.2             | 0             | # iPhone cover |
                    | 3    | *galaxy*    | 3.3             | 3.5             | 1             |                |
                    | 2    | *galaxy*    | 1.0             | 1.1             | 1             |                |
                    | 1    | *galaxy*    | 0.5             | 1.2             | 1             |                |

                    Notes:
                </script>
            </section>

            <section>
                <h1>Re-Rank Formula</h1>

                \[\begin{aligned}
                  5   &\times \text{title relevance}\\
                + 3.1 &\times \text{body relevance}\\
                + 4.3 &\times \text{product age}\\
                + 2.2 &\times \text{number of sales}
                \end{aligned} \]
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Model Store

                    ```json
                    {
                        "documentRecency":0.053789198,
                        "popularity":2.7602253E-5,
                        "totalScore":0.11210245
                    }
                    ```
                    Notes:
                </script>
            </section>


        </section>

        <section id="ltr_evaluation_section">

            <section id="ltr_evaluation" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Result Evaluation

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # DCG

                    Discounted Cumulative Gain

                    <p class="">![DCG](images/dcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    | $rel_i$ | $2^{rel_i}-1$ | $log_2(i+1)$ | $=$  |
                    |---------|---------------|--------------|------|
                    | 2       | 3             | 1            | 3    |
                    | 3       | 7             | 1.6          | 4.4  |
                    | 1       | 1             | 2            |  0.5 |
                    | $\sum$  |               |              |  7.9 |

                    More results &rarr; higher DCG &rarr; normalize<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                </script>
            </section>


            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # iDCG

                    Ideal Discounted Cumulative Gain

                    <p class="">![iDCG](images/idcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    | $rel_i$ | $2^{rel_i}-1$ | $log_2(i+1)$ | $=$ |
                    |---------|---------------|--------------|-----|
                    | 3       | 7             | 1            | 7   |
                    | 2       | 3             | 1.6          | 1.9 |
                    | 1       | 1             | 2            | 0.5 |
                    | $\sum$  |               |              | 9.4 |

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # nDCG

                    Normalized Discounted Cumulative Gain

                    <p class="">![nDCG](images/ndcg.svg)
                        <!-- .element: style="border: none; box-shadow: none;" --></p>

                    $7.9 \div 9.4 = 0.8$

                    Perfect ranking: $1.0$<!-- .element: class="fragment" data-fragment-index="" -->

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Online testing

                    A/B testing

                    Notes:
                </script>
            </section>
        </section>

        <section id="personalization_section">
            <section id="personalization" data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Personalization

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Personalization

                    * Different ranking per user
                    * Gender, age
                    * Favorite color, brand

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    Solve

                    $$f(\text{query}, \text{document}, \text{weights}, \text{user context}) = \text{rank}$$

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    # Obtain result clicks

                    | Query | Favorite color | Document   | Frequency | Rank |
                    |-------|----------------|------------|-----------|------|
                    | shirt | red            | Red shirt  | 5         | 3    |
                    | shirt | blue           | Red shirt  | 2         | 2    |
                    | shirt | red            | Blue shirt | 1         | 1    |
                    | shirt | blue           | Blue shirt | 8         | 4    |

                    Notes:
                </script>
            </section>

            <section data-markdown data-separator-notes="^Notes:">
                <script type="text/template">
                    | Rank | Query | Is Favorite Color | FeatureN | Comment |
                    |------|-------|-------------------|-----------------|-------------------------------|
                    | 3 | *red* | 1 | 1 | # Red shirt, user likes red |
                    | 2 | *red* | 0 | 0 | # Red shirt, user likes blue |
                    | 1 | *blue* | 0 | 2 | # Blue shirt, user likes red |
                    | 4 | *blue* | 1 | 0 | # Blue shirt, user likes blue |

                    Notes:
                </script>
            </section>

            <section>
                <h1>Re-Rank Formula</h1>

                \[\begin{aligned}
                5 &\times \text{title relevance}\\
                + 4.3 &\times \text{product age}\\
                + 3.5 &\times \text{user's favorite color}
                \end{aligned} \]
            </section>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Missing topics

                * Hierarchical clustering
                * Relevance feedback
                * Semantic analysis

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Feedback

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # We're hiring

                <p class="stretch>">![Developers](images/developers.gif) <!-- .element: style="width: 60%;" --></p>

                Notes:
            </script>
        </section>

        <section data-markdown data-separator-notes="^Notes:">
            <script type="text/template">
                # Final projects

                Notes:
            </script>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        anything: [
            {
                className: "chart",
                initialize: (function (container, options) {
                    container.chart = new Chart(container.getContext("2d"), options);
                    Chart.defaults.global.defaultFontColor = "black";
                    Chart.defaults.global.defaultFontSize = 50;
                })
            },
            {
                className: "plot",
                defaults: {grid: true},
                initialize: (function (container, options) {
                    options.target = "#" + container.id;
                    functionPlot(options);
                })
            },
            {
                className: "tree",
                defaults: {
                    width: 1500,
                    height: 500,
                    margin: {
                        top: 50,
                        bottom: 50,
                        left: 50,
                        right: 50
                    },
                    font: "normal 20px Arial"
                },
                initialize: (function (container, options) {
                    let treeData = JSON.parse(container.text);

                    var i = 0;

                    var tree = d3.layout.tree().size([options.height, options.width]);

                    var depthCount = function (branch) {
                        if (!branch.children) {
                            return 1;
                        }
                        return 1 + d3.max(branch.children.map(depthCount));
                    };
                    var maxDepth = depthCount(treeData);
                    var depthIncrement = options.height / (maxDepth - 1);

                    var diagonal = d3.svg.diagonal()
                        .projection(function (d) {
                            return [d.x, d.y];
                        });

                    var svg = d3.select(container.parentElement).insert("svg", function () {
                        return container;
                    })

                        .attr("width", options.width + options.margin.left + options.margin.right)
                        .attr("height", options.height + options.margin.top + options.margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + options.margin.left + "," + options.margin.top + ")");

                    update(treeData);

                    function update(root) {

                        // Compute the new tree layout.
                        var nodes = tree.nodes(root).reverse(),
                            links = tree.links(nodes);

                        nodes.forEach(function (d) {
                            d.x *= 3;
                            d.y = d.depth * depthIncrement;
                        });

                        // Declare the nodes…
                        var node = svg.selectAll("g.node")
                            .data(nodes, function (d) {
                                return d.id || (d.id = ++i);
                            });

                        // Enter the nodes.
                        var nodeEnter = node.enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function (d) {
                                return "translate(" + d.x + "," + d.y + ")";
                            });

                        nodeEnter.append("circle")
                            .attr("r", 10)
                            .style("fill", "#fff");

                        nodeEnter.append("text")
                            .attr("y", function (d) {
                                return d.children || d._children ? -30 : 30;
                            })
                            .attr("dy", ".35em")
                            .attr("text-anchor", "middle")
                            .text(function (d) {
                                return d.name;
                            })
                            .style("fill-opacity", 1)
                            .style("fill", function (d) {
                                return d.fill ? d.fill : undefined;
                            });

                        // Declare the links…
                        var link = svg.selectAll("path.link")
                            .data(links, function (d) {
                                return d.target.id;
                            });

                        // Enter the links.
                        link.enter().insert("path", "g")
                            .attr("class", "link")
                            .attr("d", diagonal);

                    }
                })
            }
        ],
        math: {
            mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js',
            config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
        },
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'node_modules/socket.io.js', async: true},
            {src: 'plugin/notes-server/client.js', async: true},
            {src: 'js/Chart.min.js'},
            {src: 'js/d3.min.js'},
            {src: 'js/function-plot.js'},
            {src: 'plugin/anything/anything.js'},
            {src: 'plugin/math/math.js', async: true},
            {src: 'plugin/reveal.js-menu-1.2.0/menu.js'},
        ]
    });
</script>
</body>
</html>
